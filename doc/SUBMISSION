Проверять при получении. Если спам - шлем через spamsender. Чистое шлем напрямую.
Схема с mailproc не подходит, т.к. клиент априори чист и его нужно заинтересовать в отправке через submission,
ответы 4xx вызовут дополнительные вопросы. Требуется экономить трафик клиента, исходящий тоже.
Логи spamassassin через лог exim добавлять в базу message-id на каждое сообщение.
Если ответ на входящее сообщение - шлем в hamtrap и логируем message-id как чистый.
Если нет отправителя в сессии - не проверяем, шлем через spamsender, логируем message-id как спам - отсутствует отправитель в сессии.
submission со временем преобразуются в spamsender, т.к. его вероятно получатели будут добавлять в RBL.
spamsender добавляет флаг X-Spam-Flag, ничего не подписывает (т.к. не все получатели будут разбираться в заголовках а банят по идентификатору в подписи).
Адреса отправителей (из сессии и заголовка сообщения) нужно проверять и добавлять в БД.
Идентифицировать клиента по IP либо по логину.

1. Идентифицировать клиента
1.1. Аутентификация (идентификатор клиента)
1.1.0. наш hostname
1.1.1. IP-адрес
1.1.2. TLS SNI
1.1.3. SMTP AUTH login
1.2. Авторизация (удостовериться в подлинности клиента)
1.2.1. наш hostname (наш realm)
1.2.2. валидация TLS сертификата
1.2.3. SMTP AUTH password
2. Проверить домен отправителя
2.1. Блокировать отправку, если домен не на этом клиенте
3. Проверить адрес отправителя
3.1. Запись отсутствует в БД - 4хх Verifying (mbxchk)
3.2. Absent - 5xx sender mbox not exists (сообщение аналогично smtp, период проверки укорочен)
3.3. Есть - 2xx
4. Проверить spamc
4.1. Учитывать trusted size (>2M)
5. Роутинг
5.1. backup
5.2. hamtrap
5.3. spamsender
5.4. интернет

Для успешной идентификации клиента нужно проверить по всем заданным (клиентом) параметрам (IP, TLS SNI, SMTP AUTH).
Ищем hostname в ou=system.
Ищем IP-адрес в ou=system (новый объект) - ?
Ищем AUTH login и tls_sni в ou=system (clientName).
AUTH password и TLS ключи/сертификаты в service=submission+realm=xxx,ou=user.
