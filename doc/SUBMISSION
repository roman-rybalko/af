Проверять при получении. Если спам - шлем через spamsender. Чистое шлем напрямую. Схема с mailproc не подходит, т.к. клиент априори чист и его нужно заинтересовать в отправке через submission,
ответы 4xx вызовут дополнительные вопросы. Требуется экономить трафик клиента, исходящий тоже.
Логи spamassassin через лог exim добавлять в базу message-id на каждое сообщение.
Если ответ ни входящее сообщение - шлем в hamtrap и логируем message-id как чистый.
Если нет отправителя в сессии - не проверяем, шлем через spamsender, логируем message-id как спам - отсутствует отправитель в сессии.
submission со временем преобразуются в spamsender, т.к. его вероятно со временем получатели будут добавлять в RBL.
spamsender добавляет флаг X-Spam-Flag, ничего не подписывает (т.к. не все получатели будут разбираться в заголовках а банят по идентификатору в подписи). 
Для начала реализовать без проверки. На втором этапе прикрутить spamassassin.
Адреса отправителей (из сессии и заголовка сообщения) нужно проверять и добавлять в БД.
Идентифицировать клиента по IP либо по логину.

1. Идентифицировать клиента
1.1. Проверить сертификат
1.1.1. Если наш IP - выдать наш сертификат и проверить по нашему ЦС
1.1.1.1. hostname соответствует IP, находится в ou=system и его realm соответствует нашему
1.1.2. Если клиентский IP - выдать клиентский сертификат и проверить по клиентскому ЦС
1.1.2.1. Ищем IP в realm=xxx+service=submission,ou=user
1.2. Проверить логин/пароль
1.2.1. Ищем логин/пароль в realm=xxx+service=submission,ou=user
2. Проверить домен отправителя
2.1. Блокировать отправку, если домен не на этом клиенте
3. Проверить адрес отправителя
3.1. Запись отсутствует в БД - 4хх Verifying (callout/vrfy на smtp)
3.2. Absent - 5xx sender mbox not exists (сообщение аналогично smtp, период проверки укорочен)
3.3. Есть - 2xx
4. Проверить на mailproc
4.1. Учитывать trusted size (>2M), все равно пересылать на mailproc для message-id
5. Роутинг
5.1. backup
5.2. hamtrap
5.3. В интернет
