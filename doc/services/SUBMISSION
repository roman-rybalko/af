Концепция
=========

Сервис отправки сообщений, сервис рассылок.
Возможно подключение конечных пользователей (логины mbox@domain.tld).


Требования
==========

1. Подключение MTA
2. Подключение MUA
3. Аутентификация по IP, TLS, логин/пароль
4. Авторизация по внутренней БД и запросами во внешний сервис (IMAP, SMTP)
5. Коды ошибок 4xx не используются
6. Базовые проверки
6.1. Проверка существования envelope-адреса отправителя
6.2. Проверка существования mime-адреса отправителя (From, Reply-To)
6.3. Проверка существования домена получателя
7. Препятствование отправке спама
8. Балансирование отправки


Описание
========

Принимаем все без ограничений, за исключением несуществующих отправителей.
Идентифицировать клиента по IP, TLS SNI либо по логину.

MX настраивается для каждого клиента, домена и отправителя. Возможно несколько MX.
Клиент самостоятельно MX не выставляет.
Для load balancing - сервис рассылок.

Пересылаем в mailproc, он выставляет вердикт. При превышении лимита отправитель будет переключен на spamsender и нагрузка с mailproc снимется.
Все, что не идет в mailproc (reply, message size) - заносим в БД самостоятельно через exim-log.

Периодически (раз в час) проверять статистику и переключать rcpt/domain/client на другой mx или spamsender.
Отправлять уведомление на клиентский или доменный admin-mail (в зависимости от локализации: rcpt -> domain admin, domain -> client admin).
Этим будет заниматься отдельный сервис (mailstat).

Статистику по частоте отправки использовать нельзя, т.к. по опыту гугла,
частота отправки сообщений может меняться при смене рода деятельности пользователя, что бывает циклично.
В решении о блокировке (переключить на spamsender) нужно учитывать соотношение чистых писем к спаму,
предположительно взять 20/80 (по принципу Pareto).

Больше определенного размера в mailproc не пересылаем, вердикт логируем в exim-log, затем в БД.
Без message-id - добавляем message-id.
Если ответ на входящее сообщение - шлем в hamtrap и логируем message-id как чистый.
Нет отправителя в сессии - не шлем в mailproc, шлем через spamsender.

Сервис submission со временем преобразуются в spamsender, т.к. вероятно получатели его будут добавлять в RBL.
Сервис spamsender добавляет флаг X-Spam-Flag.

Адреса отправителей (из сессии и заголовка сообщения) нужно проверять и добавлять в БД submission.
Проверка адресов отправителей - это нужная фича (админу будет полезно узнать, что адрес не принимает почту).
БД smtp не используется.

Флаг flag_mb_absent не нужен.
Если почтового ящика нет - проверяем. Если ящик удален - нет смысла хранить настройки,
создадут заново - будут новые настройки.

При отправке проверяем наличие отправителя в БД. Пустой отправитель - шлем через spamsender.
Отправитель отсутствует в БД - проверяем его на сервере клиента, синхронно.
Нужно проверить адрес -> скрпит ${run...} -> VRFY на smtp своего realm -ok-> добавляем в базу submission (синхронно)
VRFY на smtp своего realm -fail-> отвечаем 5xx
VRFY на smtp своего realm -> mbxchk -ok-> обновляем базу smtp (синхронно)
mbxchk -fail-> обновляем базу smtp (синхронно)
Проверки делаем синхронно, т.к. это новый адрес и его нужно скорее задействовать в работу.
Обновления делаем синхронно, т.к. уже и так задержка, для упрощения системы (иначе требуется добавлять этот адрес
асинхронно из cron), иначе клиент попробует отправить повторно и снова будет задержка т.к. данные в базе не успели обновиться.

Вызов mbxchk из submission требует каталог с данными smtp, который лежит на другом сервере.
Для уменьшения связности проверку производить через сервис smtp.
Так-же WEB-консоль может обращаться к smtp с командами VRFY и ETRN.

Запрос через сервис smtp предпочтительней, т.к. клиент ожидает обращений к своему серверу именно с серверов smtp.

Возможно сделать запрос через HTTP - что-бы не усложнять конфигурацию сервиса smtp.
Но конфигурация системы усложняется больше чем усложняется конфигурация сервиса smtp.
Для реализации запроса через сервис smtp требуется дополнительно включить acl
и возможно минимальные правки в routers (flag_mb_absent), которые покрыты тестами.

Отдельный процесс регулярно (из cron) перепроверяет почтовые ящики, удаляет несуществующие.
Ящики для перепроверки задает exim в своем логе. Регулярно перепроверять все ящики ресурсоемко.
Exim/submission записывает в лог просроченные ящики, но не блокирует отправку (ящики удаляются редко).
По временам обновления можно будет обнаружить, что mbxchk не работает.

IP-адрес, SMTP AUTH password и TLS ключи/сертификаты решено хранить в ou=user, что-бы не перегружить ou=system.
Хоть данные в ou=user могут быть недоступны (репликация не завершена) или не актуальны (если сервер вывели
из realm - клиент получит уведомление в MAIL), отсутствие информации об IP-адресе, логине или параметрах TLS
приведет ко временной ошибке соединения - клиент повторит попытку позже или сразу но на другой сервер.
При обработке MAIL в первую очередь проверить realm для домена отправителя.

Ищем IP-адрес в service=submission+realm=xxx,ou=user.
SMTP AUTH login и TLS SNI содержат clientName.
SMTP AUTH password и TLS ключи/сертификаты находятся в service=submission+realm=xxx,ou=user.

В SDB хранить sender и queue-id.

Скрывать IP-адреса отправителей - клиентская настройка.

Хорошую почту (отправляемую через mx) подписывать DKIM - доменом клиента, ключ генерировать и скрывать.
Плохую почту (отправляемую через spamsender) не подписывать DKIM.
Требовать от клиента DMARC. Это позволит формально отправлять спам, но гарантирует блокировку этого спама на получателе.
Для начала требовать любой политики DMARC, после запуска требовать reject.
Была идея использовать feedback для выявления проблем в конфигурации - нет смысла,
т.к. подмена адреса отправителя в спаме присутствует всегда и это не означает проблемы в конфигурации.

Алгоритм
========

1. Идентифицировать клиента
1.1. Аутентификация (идентификатор клиента)
1.1.0. наш hostname
1.1.1. IP-адрес
1.1.2. TLS SNI
1.1.3. SMTP AUTH login
1.2. Авторизация (удостовериться в подлинности клиента)
1.2.1. наш hostname (наш realm)
1.2.2. валидация TLS сертификата
1.2.3. SMTP AUTH password
2. Проверить домен отправителя
2.1. Блокировать отправку, если домен не на этом клиенте
2.2. Блокировать отправку, если не задан DMARC для домена
3. Проверить адрес отправителя (SMTP и MIME)
3.1. Запись отсутствует в БД - 4хх Verifying (mbxchk)
3.2. Absent - 5xx sender mbox not exists (сообщение аналогично smtp, период проверки укорочен)
3.3. Есть - 2xx
4. Проверить message-id и sender
4.1. Нет message-id - добавляем
4.2. Есть message-id и sender в БД - 2xx duplicate prev-queue-id, отбрасываем - ??? а если расылка?!
4.3. Есть message-id в БД но другой sender - 5xx actual_sender prev-queue-id
5. Учитывать trusted size (>2M)
6. Роутинг
6.1. mailproc
6.2. backup
6.3. hamtrap
6.4. spamsender
6.5. mx
6.5.1. Подписать dkim
6.6. dns
6.6.1. Подписать dkim
