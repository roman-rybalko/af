Входящий роутинг

-> - redirect_router
=> - errors_to
() - defaults
[] - condition
{} - unseen

* service [@services] {stop} (-> service) => error
* mailproc [flag_mailproc] {stop} (-> service) => error
* hamtrap [flag_hamtrap && sys_hamtrap] {continue} (-> service) => error
* spamtrap [flag_spamtrap && sys_spamtrap] {continue} (-> service) => error
* spamaddress user/domain/client [flag_spam && user_spt] {continue} -> spambox => error
* spambox user/domain/client [flag_spam && user_spt] {continue} -> user_spam_block => error
* user_spam_block # не пропускаем спам если !user_spt
* backup user/domain/client {continue} -> spam_block => error
* spam_block # не пропускаем спам
* redirect user/domain/client {stop} -> user_spam_block => error
* mx user/domain/client {stop} => bounce
* submission {stop} => error

Для spam проверять afUSMTPDMBIsAbsent,
т.к. отправка производится с адреса afUSMTPDMailBox,
нет возможности отправлять с несуществующего адреса.
Нет смысла проверять для backup и mx (теоретически)
т.к. несуществующий MailBox до этих роутеров не дойдет:
если включен spamtrap, то сообщение поглотит spam_last_router,
если spamtrap отключен, тогда будет отвергнут RCPT.

Была идея пересылать выходящее сообщение на соседний smtp в случае недоставки.
Нужно предотвратить пересылку сообщения spam- или backup-роутером, для этого добавлять заголовок. Этот заголовок нужно
учитывать только при получении сообщения с соседнего smtp и удалять его при передаче клиенту.
Но это ломает retry rules и неконтролируемо добавляет trace headers (Received).
Этот функционал требуется для вывода сервера из работы.
Для вывода из работы достаточно изменить конфигурацию - сделать единственный роутер для отправки на соседний smtp.
Дублированием отправки в spam и backup можно принебречь (до тех пор, когда, по каким либо причинам, выводы из работы
станут регулярными - тогда реализовать заголовок).
