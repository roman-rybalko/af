exim_user = exim
exim_group = exim
log_file_path = /usr/local/advancedfiltering/exim/%slog
process_log_path = /usr/local/advancedfiltering/exim/exim-process.info
spool_directory = /usr/local/advancedfiltering/exim
split_spool_directory = true
never_users = root
daemon_smtp_ports = 25 : 137 : 138 : 139 : 445
host_lookup = *
rfc1413_hosts = :
rfc1413_query_timeout = 0s
smtp_receive_timeout = 5s
local_scan_timeout = 5s
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d
tls_advertise_hosts = *
tls_try_verify_hosts = *
tls_certificate = /usr/local/etc/ssl/smtp.services.advancedfiltering.net.crt
tls_privatekey = /usr/local/etc/ssl/smtp.services.advancedfiltering.net.key
tls_verify_certificates = /usr/local/etc/ssl/ca
tls_crl = /usr/local/etc/ssl/ca
acl_smtp_connect = connect_acl
acl_smtp_helo = helo_acl
acl_smtp_mail = mail_acl
acl_smtp_rcpt = rcpt_acl
acl_smtp_data = data_acl
received_header_text = Received:\
  ${if def:sender_rcvhost { from $sender_rcvhost}{ from localhost}} by $primary_hostname\
  ${if def:received_protocol { with $received_protocol}}\
  ${if def:tls_cipher { ($tls_cipher)}}\
  ${if def:tls_peerdn { ($tls_peerdn)}}\n \
  id $message_exim_id\
  ${if def:sender_address { (envelope-from <$sender_address>)}}\
  ${if def:received_for { for $received_for}}

# Lightweight Directory Access Protocol Connection
LDAP_C = ldapi://%2fvar%2frun%2fopenldap%2fldapi
# System LDAP DN
S_LDAP_DN = ou=system,o=advancedfiltering
# System SMTP LDAP DN
S_SMTP_LDAP_DN = afSServiceName=smtp,S_LDAP_DN
# User SMTP LDAP DN
U_SMTP_LDAP_DN = afUServiceName=smtp,ou=user,o=advancedfiltering
# System Realms
S_REALMS = ${sg {${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$primary_hostname},S_LDAP_DN?afSHostRealm?base} }} {,\\s*} {:} }

message_size_limit = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPMaxMessageSize?base} }

begin acl

# Domain Name System Block List
# accept - match, deny - not match
dnsbl_acl:
  deny
    condition = $acl_c_s_tp_f
    logwrite = DEBUG: dnsbl: trusted port
  accept
    dnslists = <, ${lookup ldap{LDAP_C/$acl_c_dbsbl_ldap_dn?afSSMTPDNSBLDomainName?base}}
    set acl_c_dnsbl_m = $sender_host_address is listed at $dnslist_domain ($dnslist_value: $dnslist_text)
    logwrite = DEBUG: dnsbl
  deny

# General Black/White List
# accept - match, deny - not match
gen_bwl_acl:
  warn
    set acl_c_bwl_d = ${lookup ldap{LDAP_C/$acl_c_bwl_ldap_q,$acl_c_bwl_ldap_dn?objectClass,afSMTPBWListIsBlack?base}}
  accept
    condition = ${extract {afSMTPBWListIsBlack}{$acl_c_bwl_d}{true}{false}}
    # Result
    set acl_c_bwl_r = black
    logwrite = DEBUG: bwl: black
  accept
    condition = ${if bool_lax{$acl_c_bwl_d}}
    set acl_c_bwl_r = white
    logwrite = DEBUG: bwl: white
  deny

# Sender Host Black/White List
# accept - match, deny - not match
sh_bwl_acl:
  accept
    set acl_c_bwl_ldap_q = afSMTPBWListHostAddress=${quote_ldap_dn:$sender_host_address}
    acl = gen_bwl_acl
    set acl_c_bwl_m = sender host address
    logwrite = DEBUG: sha_bwl
  deny
    ! condition = ${if bool_lax{$sender_host_name}}
    logwrite = DEBUG: shn_bwl: sender host name unknown
  accept
    set acl_c_bwl_ldap_q = afSMTPBWListHostName=${quote_ldap_dn:$sender_host_name}
    acl = gen_bwl_acl
    set acl_c_bwl_m = sender host name
    logwrite = DEBUG: shn_bwl
  deny

# Certificate Black/White List
# accept - match, deny - not match
cert_bwl_acl:
  warn
    set acl_c_bwl_m = ""
  deny
    ! condition = ${if bool_lax{$tls_peerdn}}
  warn
    set acl_c_bwl_ldap_q = afSMTPBWListCertificateSubject=${quote_ldap_dn:$tls_peerdn}
    acl = gen_bwl_acl
    set acl_c_bwl_m = certificate
    logwrite = DEBUG: cert_bwl ($tls_peerdn)
  accept
    condition = ${if bool_lax{$acl_c_bwl_m}}
    condition = ${if eq{$acl_c_bwl_r}{white}}
    verify = certificate
  accept
    condition = ${if bool_lax{$acl_c_bwl_m}}
    condition = ${if eq{$acl_c_bwl_r}{black}}
  deny

# Sender Mail Address Black/White List
# accept - match, deny - not match
sma_bwl_acl:
  warn
    set acl_c_bwl_m = ""
  warn
    set acl_c_bwl_ldap_q = afSMTPBWListSenderMailAddress=${quote_ldap_dn:$sender_address}
    acl = gen_bwl_acl
    set acl_c_bwl_m = sender mail address
    logwrite = DEBUG: sma_bwl
  accept
    condition = ${if bool_lax{$acl_c_bwl_m}}
    condition = ${if eq{$acl_c_bwl_r}{white}}
    ! condition = ${if bool_lax{$acl_m_spf_m}}
  accept
    condition = ${if bool_lax{$acl_c_bwl_m}}
    condition = ${if eq{$acl_c_bwl_r}{black}}
  deny

# System Black List Message
S_BL_M = Access denied (system policy, $acl_c_bwl_m)
# System White List Message
S_WL_M = OK (system policy, $acl_c_bwl_m)
# System Black/White List
# include by "require"
# accept - continue, deny - 5xx
s_bwl_acl:
  accept
    set acl_c_bwl_r = ""
    ! acl = $acl_c_s_bwl_acl
  deny
    ! condition = $acl_c_s_st_f
    condition = ${if eq{$acl_c_bwl_r}{black}}
    message = S_BL_M
    logwrite = DEBUG: s_bwl: black
  accept
    condition = $acl_c_s_st_f
    condition = ${if eq{$acl_c_bwl_r}{black}}
    set acl_c_s_st_m = S_BL_M
    logwrite = DEBUG: s_bwl: black (spamtrap)
  accept
    condition = ${if eq{$acl_c_bwl_r}{white}}
    set acl_c_s_wl_m = S_WL_M
    logwrite = DEBUG: s_bwl: white
  accept
    logwrite = ERROR: UNKNOWN BWL RESULT: $acl_c_bwl_r

# System SMTP Trusted Port Data
S_TP_D = ${sg {${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPTrustedPort?base} }} {,\\s*} {:} }
# ... Trusted Port Flag
S_TP_F = ${if inlist{$received_port}{S_TP_D}}
# ... Spam Trap Probability Numerator
S_STPN = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPSpamTrapProbabilityNumerator?base}}
# ... Spam Trap Probability Denominator
S_STPD = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPSpamTrapProbabilityDenominator?base}}
# ... Spam Trap Flag
S_ST_F = ${if >{S_STPN}{${randint:S_STPD}}}
# System MailBox Timeout Data
S_MBTO_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPMailBoxTimeout?base} }
# System Trusted Message Size
S_TMS_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPTrustedMessageSize?base} }
connect_acl:
  warn
    # System Trusted Port Flag
    set acl_c_s_tp_f = S_TP_F
    # System SpamTrap Flag
    set acl_c_s_st_f = S_ST_F
    # System MailBox Cutoff Time Data
    set acl_c_s_mbct_d = ${eval10:$tod_epoch-S_MBTO_D}
    # System Trusted Message Size Data
    set acl_c_s_tms_d = S_TMS_D
    # System Realm(s)
    set acl_c_s_realms = S_REALMS
    set acl_c_bwl_ldap_dn = S_SMTP_LDAP_DN
    control = dkim_disable_verify
    logwrite = DEBUG: acl_c_s_tp_f=$acl_c_s_tp_f acl_c_s_st_f=$acl_c_s_st_f acl_c_s_realms=$acl_c_s_realms
  require
    set acl_c_s_bwl_acl = sh_bwl_acl
    acl = s_bwl_acl
  warn
  	! condition = ${if bool_lax{$acl_c_s_wl_m}}
    set acl_c_dnsbl_ldap_dn = S_SMTP_LDAP_DN
    acl = dnsbl_acl
  accept
    condition = ${if bool_lax{$acl_c_s_wl_m}}
    message = smtp.services.advancedfiltering.net ESMTP $acl_c_s_wl_m
  accept
    condition = ${if bool_lax{$acl_c_s_st_m}}
    message = $acl_c_s_st_m
  accept
    # smtp_banner
    message = smtp.services.advancedfiltering.net ESMTP${if bool_lax{$acl_c_s_tp_f}{ trustedport}{}}${if bool_lax{$acl_c_s_st_f}{ spamtrap}{}}

helo_acl:
  accept
    condition = ${if bool_lax{$acl_c_s_wl_m}}
  accept
    condition = ${if bool_lax{$acl_c_s_st_m}}
  require
    set acl_c_s_bwl_acl = cert_bwl_acl
    acl = s_bwl_acl
  accept
    condition = ${if bool_lax{$acl_c_s_wl_m}}
    message = smtp.services.advancedfiltering.net $acl_c_s_wl_m
  accept
    condition = ${if bool_lax{$acl_c_s_st_m}}
    message = $acl_c_s_st_m
  accept
    message = smtp.services.advancedfiltering.net

mail_acl:
  accept
    condition = ${if bool_lax{$acl_c_s_wl_m}}
  accept
    condition = ${if bool_lax{$acl_c_s_st_m}}
  warn
    spf = fail
    set acl_m_spf_m = $sender_host_address is not allowed to send mail from $sender_address_domain
    logwrite = DEBUG: spf fail
  require
    set acl_c_s_bwl_acl = sma_bwl_acl
    acl = s_bwl_acl
  accept
    condition = ${if bool_lax{$acl_c_s_wl_m}}
    message = $acl_c_s_wl_m
  accept
    condition = ${if bool_lax{$acl_c_s_st_m}}
    message = $acl_c_s_st_m
  accept

# User SMTP Realm DN
U_SMTP_R_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+U_SMTP_LDAP_DN
# User SMTP Realm Client DN
U_SMTP_R_C_LDAP_DN = afUClientName=${quote_ldap_dn:$acl_m_u_client},U_SMTP_R_LDAP_DN
# User SMTP Realm Client Domain DN
U_SMTP_R_C_D_LDAP_DN = afUSMTPDomainName=${quote_ldap_dn:$acl_m_u_domain},U_SMTP_R_C_LDAP_DN
# User SMTP Realm Client Domain Mail Box DN
U_SMTP_R_C_D_MB_LDAP_DN = afUSMTPDMBLocalPart=${quote_ldap_dn:$local_part},U_SMTP_R_C_D_LDAP_DN

# Lookup recipient domain
domain_rcpt_acl:
  accept
    # User Domain
    set acl_m_u_domain = ${lookup ldap{LDAP_C/afUSMTPDomainName=${quote_ldap_dn:$domain},U_SMTP_R_C_LDAP_DN?afUSMTPDomainName?base}}
    condition = ${if bool_lax{$acl_m_u_domain}}
    logwrite = DEBUG: acl_m_u_domain=$acl_m_u_domain
  accept
    set acl_m_u_domain = ${lookup ldap{LDAP_C/U_SMTP_R_C_LDAP_DN?afUSMTPDomainName?sub?(&(objectClass=afUSMTPDomain)(afUSMTPDomainAliasName=${quote_ldap:$domain}))}}
    condition = ${if bool_lax{$acl_m_u_domain}}
    logwrite = DEBUG: acl_m_u_domain=$acl_m_u_domain (alias)
  defer
    message = Replicating, try again later

# User Black List Message
U_BL_M = Access denied ($acl_m_bwl_category_m, $acl_c_bwl_m)
# User White List Message
U_WL_M = OK ($acl_m_bwl_category_m, $acl_c_bwl_m)
# User Black/White List
# accept - match, deny - not match
u_bwl_acl:
  deny
    set acl_c_bwl_r = ""
    ! acl = $acl_m_u_bwl_acl
  accept
    condition = ${if eq{$acl_c_bwl_r}{black}}
    # User Black/White List Message
    set acl_m_u_bwl_m = U_BL_M
    logwrite = DEBUG: u_bwl: black
  accept
    condition = ${if eq{$acl_c_bwl_r}{white}}
    set acl_m_u_bwl_m = U_WL_M
    # User White List Count
    set acl_m_u_wl_c = ${eval:$acl_m_u_wl_c+1}
    logwrite = DEBUG: u_bwl: white
  deny
    logwrite = ERROR: UNKNOWN BWL RESULT: $acl_c_bwl_r

# User Mail Box Absent Message
U_MBA_M = Mail box does not exist
# User SPF Message
U_SPF_M = Access denied (SPF: $acl_m_spf_m)
# User DNSBL Message
U_DNSBL_M = Access denied (DNSBL: $acl_c_dnsbl_m)

rcpt_acl:
  # * проверка realm для домена
  # ** нет домена => 5xx The domain is not in service, stop
  # ** чужой realm => 4xx Moved, try another host, stop
  deny
    # User Client (name/id)
    set acl_m_u_client = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
    logwrite = DEBUG: acl_m_u_client=$acl_m_u_client
    ! condition = ${if bool_lax{$acl_m_u_client}}
    message = The domain is not in service
  defer
    # User Realm
    set acl_m_u_realm = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:$acl_m_u_client},S_LDAP_DN?afSClientRealm?base}}
    logwrite = DEBUG: acl_m_u_realm=$acl_m_u_realm
    ! condition = ${if inlist{$acl_m_u_realm}{$acl_c_s_realms}}
    message = Moved, try another host
  warn
    set acl_m_u_realms = ${if bool_lax{$acl_m_u_realms} {$acl_m_u_realms:$acl_m_u_realm} {$acl_m_u_realm} }
  require
    acl = domain_rcpt_acl

  # * проверка адреса получателя в afMailBox (с учетом MailBox Timeout)
  # ** fail => 4xx Your data is verifying, try again in 5 minutes, log, stop
  # ** ok, absent => sys_spamtrap ? ok, flag_spamtrap+="Mail box does not exist", stop : 5xx Mail box does not exist, stop
  defer
    # User Mail Box Data
    set acl_m_u_mb_d = ${lookup ldap{LDAP_C/U_SMTP_R_C_D_MB_LDAP_DN?objectClass,afUSMTPDMBIsAbsent?base?(afUSMTPDMBTimeCreated>=$acl_c_s_mbct_d)}}
    ! condition = ${if bool_lax{$acl_m_u_mb_d}}
    message = Your data is verifying, try again later
    logwrite = AdvancedFiltering:NewMailBox:<$local_part>Domain:<$acl_m_u_domain>Client:<$acl_m_u_client>Realm:<$acl_m_u_realm>
  deny
    ! condition = $acl_c_s_st_f
    condition = ${extract {afUSMTPDMBIsAbsent}{$acl_m_u_mb_d}{true}{false}}
    message = U_MBA_M
  accept
    condition = $acl_c_s_st_f
    condition = ${extract {afUSMTPDMBIsAbsent}{$acl_m_u_mb_d}{true}{false}}
    set acl_c_s_st_m = U_MBA_M
    message = U_MBA_M

  # * проверка черных списков (ip, hostname, certificate) для [addr to, domain to, client to]
  # ** ok => 5xx Access denied (local user policy), stop
  # * проверка белых списков (ip, hostname, certificate) для [addr to, domain to, client to]
  # ** ok => flag_user_wl+=1, ok, stop
  warn
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_MB_LDAP_DN
    set acl_m_bwl_category_m = user recipient policy
    set acl_m_u_bwl_acl = sh_bwl_acl
    ! acl = u_bwl_acl
    set acl_m_u_bwl_acl = cert_bwl_acl
    ! acl = u_bwl_acl
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_LDAP_DN
    set acl_m_bwl_category_m = user domain policy
    set acl_m_u_bwl_acl = sh_bwl_acl
    ! acl = u_bwl_acl
    set acl_m_u_bwl_acl = cert_bwl_acl
    ! acl = u_bwl_acl
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_LDAP_DN
    set acl_m_bwl_category_m = user policy
    set acl_m_u_bwl_acl = sh_bwl_acl
    ! acl = u_bwl_acl
    set acl_m_u_bwl_acl = cert_bwl_acl
    ! acl = u_bwl_acl
  deny
    condition = ${if eq{$acl_c_bwl_r}{black}}
    message = $acl_m_u_bwl_m
    logwrite = AdvancedFiltering:Log:Reject
  accept
    condition = ${if eq{$acl_c_bwl_r}{white}}
    message = $acl_m_u_bwl_m

  # * flag_spf => sys_spamtrap ? ok, flag_spamtrap+="Access denied (SPF: ...)", stop : 5xx Access denied (SPF: ...), stop
  deny
    ! condition = $acl_c_s_st_f
    condition = ${if bool_lax{$acl_m_spf_m}}
    message = U_SPF_M
  accept
    condition = $acl_c_s_st_f
    condition = ${if bool_lax{$acl_m_spf_m}}
    set acl_c_s_st_m = U_SPF_M
    message = U_SPF_M

  # * проверка черных списков (addr from) для [addr to, domain to, client to]
  # ** ok => 5xx Access denied (local user policy), stop
  # * проверка белых списков (addr from) для [addr to, domain to, client to]
  # ** ok => flag_user_wl+=1, ok, stop
  warn
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_MB_LDAP_DN
    set acl_m_bwl_category_m = user recipient policy
    set acl_m_u_bwl_acl = sma_bwl_acl
    ! acl = u_bwl_acl
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_LDAP_DN
    set acl_m_bwl_category_m = user domain policy
    set acl_m_u_bwl_acl = sma_bwl_acl
    ! acl = u_bwl_acl
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_LDAP_DN
    set acl_m_bwl_category_m = user policy
    set acl_m_u_bwl_acl = sma_bwl_acl
    ! acl = u_bwl_acl
  deny
    condition = ${if eq{$acl_c_bwl_r}{black}}
    message = $acl_m_u_bwl_m
    logwrite = AdvancedFiltering:Log:Reject
  accept
    condition = ${if eq{$acl_c_bwl_r}{white}}
    message = $acl_m_u_bwl_m
  
  # * flag_dnsbl => sys_spamtrap ? ok, flag_spamtrap+="Access denied (DNSBL: ...)", stop : 5xx Access denied (DNSBL: ...), stop
  deny
    ! condition = $acl_c_s_st_f
    condition = ${if bool_lax{$acl_c_dnsbl_m}}
    message = U_DNSBL_M
  accept
    condition = $acl_c_s_st_f
    condition = ${if bool_lax{$acl_c_dnsbl_m}}
    set acl_c_s_st_m = U_DNSBL_M
  
  accept

# Message References
U_MR_D = $bheader_in-reply-to: $bheader_references:
# Message References Fix 1
U_MR_F1 = ${sg{U_MR_D}{^\\s+}{}}
# Message References Fix 2
U_MR_F2 = ${sg{U_MR_F1}{\\s+\$}{}}
U_MR_F3 = ${sg{U_MR_F2}{^[^\<]*\<}{}}
U_MR_F4 = ${sg{U_MR_F3}{\>[^\>]*\$}{}}
U_MR_F5 = ${sg{U_MR_F4}{\>[^\<\>]*\<}{\<}}
U_MR_F6 = ${map {<\< U_MR_F5} {${str2b64:$item}}}
U_MR_F7 = ${tr{U_MR_F6}{/+=}{.-_}}
U_MR_F8 = ${sg{U_MR_F7}{\<}{:}}
# Message References Final Fix
U_MR_FF = U_MR_F8

# User Submission DataBase LDAP DN
U_SDB_LDAP_DN = afUServiceName=sdb,ou=user,o=advancedfiltering
# User Submission DataBase Realm LDAP DN List
U_SDB_R_LDAP_DN_L = ${map {$acl_m_u_realms} {afUServiceRealm=${quote_ldap_dn:$item}+U_SDB_LDAP_DN} }

# User SDB Realm Message Outgoing
U_SDB_R_MO_VALUE_ORIG = ${sg {$value} {\\|.*\$} {} }
U_SDB_R_MO_VALUE_MID = ${sg {:U_SDB_R_MO_VALUE_ORIG} {:} {:afUSMTPMessageId=${quote_ldap_dn:$item},} }
U_SDB_R_MO_VALUE_ALL = ${reduce {U_MR_FF} {U_SDB_R_LDAP_DN_L|} {${value}U_SDB_R_MO_VALUE_MID} }
U_SDB_R_MO_LDAP_DN_L = ${sg {U_SDB_R_MO_VALUE_ALL} {^.+\\|:} {} }
U_SDB_R_MO_LDAP_I = ${lookup ldap{LDAP_C/$item?afUSMTPMessageSenderMailAddress?base}}

# Message Id/Incoming
U_MI_D = $rheader_message-id:
# Message Id Fix 1
U_MI_F1 = ${sg{U_MI_D}{^\\s+}{}}
# Message Id Fix 2
U_MI_F2 = ${sg{U_MI_F1}{\\s+\$}{}}
U_MI_F3 = ${sg{U_MI_F2}{^[^\<]*\<}{}}
U_MI_F4 = ${sg{U_MI_F3}{\>[^\>]*\$}{}}
U_MI_F5 = ${str2b64:U_MI_F4}
U_MI_F6 = ${tr{U_MI_F5}{/+=}{.-_}}
# Message Id Final Fix
U_MI_FF = U_MI_F6

# User SMTP DataBase LDAP DN
U_SMTPDB_LDAP_DN = afUServiceName=smtpdb,ou=user,o=advancedfiltering
# User SMTP DataBase Realm LDAP DN List
U_SMTPDB_R_LDAP_DN_L = ${map {$acl_m_u_realms} {afUServiceRealm=${quote_ldap_dn:$item}+U_SMTPDB_LDAP_DN} }

# SMTPDB Realm Message Incoming LDAP DNs
U_SMTPDB_R_MI_LDAP_DN_L = ${map {U_SMTPDB_R_LDAP_DN_L} {afUSMTPMessageId=${quote_ldap_dn:U_MI_FF},$item} }
# SMTPDB Realm Message Incoming ... Item
U_SMTPDB_R_MI_spam_I = ${lookup ldap{LDAP_C/$item?afUSMTPMessageSpamDescription?base} }
# ... Data
U_SMTPDB_R_MI_spam_D = ${reduce {U_SMTPDB_R_MI_LDAP_DN_L} {} {$value U_SMTPDB_R_MI_spam_I} }
U_SMTPDB_R_MI_sender_I = ${lookup ldap{LDAP_C/$item?afUSMTPMessageSenderMailAddress?base} }
# ... List
U_SMTPDB_R_MI_sender_L = ${map {U_SMTPDB_R_MI_LDAP_DN_L} {U_SMTPDB_R_MI_sender_I} }
U_SMTPDB_R_MI_sender_D = ${reduce {U_SMTPDB_R_MI_sender_L} {} {$value $item} }
U_SMTPDB_R_MI_bad_sender_D = ${filter {U_SMTPDB_R_MI_sender_L} { and{ { bool_lax{$item} } { !eqi{$item}{$sender_address} } } } }

data_acl:
  warn
    set acl_m_u_recipients = $recipients
  accept
    condition = ${if bool_lax{$acl_c_s_st_m}}
    control = fakereject/$acl_c_s_st_m
  accept
    condition = ${if bool_lax{$acl_c_s_wl_m}}
  accept
    condition = ${if ={$acl_m_u_wl_c}{$recipients_count}}
  
  # * проверка Message-Id в afMessageIncoming
  # ** нет MessageId => 5xx SPAM: No Message-ID header, stop
  warn
    ! condition = ${if bool_lax{U_MI_D}}
    # User Message Incoming Spam Message
    set acl_m_u_mi_s_m = No Message-ID header
  # ** ok, afIsSpam => 5xx SPAM: afSpamDescription, stop
  warn
    ! condition = ${if bool_lax{$acl_m_u_mi_s_m}}
    logwrite = DEBUG: Spam descr: U_SMTPDB_R_MI_spam_D
    condition = ${if bool_lax{U_SMTPDB_R_MI_spam_D}}
    set acl_m_u_mi_s_m = U_SMTPDB_R_MI_spam_D
  # ** не совпадает sender => 5xx SPAM: Several senders for the same Message-ID, stop, spamtrap
  warn
    ! condition = ${if bool_lax{$acl_m_u_mi_s_m}}
    logwrite = DEBUG: Bad sender: U_SMTPDB_R_MI_bad_sender_D
    condition = ${if bool_lax{U_SMTPDB_R_MI_bad_sender_D}}
    set acl_c_s_st_m = Several senders for the same Message-ID
  # ... stop
  accept
    condition = ${if bool_lax{$acl_m_u_mi_s_m}}
    control = fakereject/SPAM: $acl_m_u_mi_s_m
  accept
    condition = ${if bool_lax{$acl_c_s_st_m}}
    control = fakereject/$acl_c_s_st_m
  # ** ok => ok, stop
  accept
    condition = ${if bool_lax{U_SMTPDB_R_MI_sender_D}}
  
  # * проверка In-Reply-To, References в afMessageOutgoing
  # ** ok => ok, stop
  accept
    condition = ${if bool_lax{U_MR_D}}
    logwrite = DEBUG: realms: ${reduce {$acl_m_u_realms} {} {$value $item} }
    logwrite = DEBUG: references: ${reduce {U_SDB_R_MO_LDAP_DN_L} {} {$value $item} }
    logwrite = DEBUG: senders: ${reduce {U_SDB_R_MO_LDAP_DN_L} {} {$value U_SDB_R_MO_LDAP_I} }
    logwrite = DEBUG: recipients: $recipients
    condition = ${if forany {U_SDB_R_MO_LDAP_DN_L} { inlist {U_SDB_R_MO_LDAP_I} {<, $recipients} } }
  
  # * message_size >= sys_trustedmessagesize
  # ** ok => ok, stop
  accept
    condition = ${if >{$message_size}{$acl_c_s_tms_d}}
    message = OK id=$message_exim_id (system policy, trusted message size)
  
  # * 4xx Your data is verifying, try again later, forward to mailproc
  accept
    control = fakedefer/Your data is verifying, try again later
    set acl_m_mp_f = true

begin routers

# Router Client
R_CLIENT = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
# Router Client Realm
R_C_REALM = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:R_CLIENT},S_LDAP_DN?afSClientRealm?base}}

# (is needed for service_* routers and submission_* routers)
# Router Address_Data Realm LDAP Query (needed for service_* routers and submission_* routers)
R_AD_R_LDAP_Q = afSHostRealm=${quote_ldap_dn:${extract {realm} {$address_data} }}
# Router Address_Data Realm Flag
R_AD_R_F = ${extract {realm} {$address_data} }
# Router System Realm LDAP Query
R_SYS_R_LDAP_Q = ${reduce {S_REALMS} {|} {$value(afSHostRealm=${quote_ldap_dn:$item})} }
# Router Services Realm LDAP Q
R_S_R_LDAP_Q = ${if bool_lax{R_AD_R_F} {R_AD_R_LDAP_Q} {R_SYS_R_LDAP_Q} }

# * service

# errors_to addresses need to be verified
service_verify_router:
  verify_only = true
  domains = services.advancedfiltering.net
  driver = accept

service_router:
  domains = services.advancedfiltering.net
  driver = manualroute
  debug_print = address_data = $address_data, sys_r = R_SYS_R_LDAP_Q
  route_data = ${tr {${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_S_R_LDAP_Q)(afSHostServiceName=$local_part))} }} {\n} {:} }
  hosts_randomize = true
  transport = service_transport
  address_data = system_authenticator="true" $address_data
  errors_to = error@services.advancedfiltering.net

service_defer_router:
  domains = services.advancedfiltering.net
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net

# Router Services Headers Delete
R_SH_D = X-AdvancedFiltering-Sender:X-AdvancedFiltering-Recipient:X-AdvancedFiltering-Recipients:X-AdvancedFiltering-Realms
# Router Services Headers Add
R_SH_A = X-AdvancedFiltering-Sender: $sender_address\nX-AdvancedFiltering-Recipient: $local_part@$domain\nX-AdvancedFiltering-Recipients: ${tr{$acl_m_u_recipients}{,}{ }}\nX-AdvancedFiltering-Realms: ${tr{$acl_m_u_realms}{:}{ }}

# * mailproc
mailproc_router:
  condition = $acl_m_mp_f
  driver = redirect
  data = mailproc@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_SH_D
  headers_add = R_SH_A

# Router Client LDAP DN
R_C_LDAP_DN = afUClientName=${quote_ldap_dn:R_CLIENT},afUServiceRealm=${quote_ldap_dn:R_C_REALM}+U_SMTP_LDAP_DN
# Router Client Domain LDAP DN
R_CD_LDAP_DN = afUSMTPDomainName=${quote_ldap_dn:$domain},R_C_LDAP_DN
# Router Client Domain Mail Box LDAP DN
R_CDM_LDAP_DN = afUSMTPDMBLocalPart=${quote_ldap_dn:$local_part},R_CD_LDAP_DN
# Router MailBox Absent Data
R_MBA_D = ${lookup ldap{LDAP_C/R_CDM_LDAP_DN?afUSMTPDMBIsAbsent?base} }

# *************************************************************************************************

# same contents for all spam_* and backup_* routers
# (except condition clause)

# *************************************************************************************************

# Router General LDAP DN
R_LDAP_DN = ""

# Router Copy Target Data
R_CT_D = ""

# Router Copy Sender Data
R_CS_D = ""

# Router Copy Headers Delete
# X-AdvancedFiltering-Sender-XXX header for separate batch
R_CH_D = X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Sender-XXX
# Router Copy Headers Add
R_CH_A = X-AdvancedFiltering-Return-Path: $sender_address

# * spam

R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all spam_user_ routers
R_CT_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPSpamMailAddress?sub?(objectClass=afUSMTPSpamTarget)} }
R_CH_D == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spam_mailbox_router:
  condition = ${if or{ {bool_lax{$acl_c_s_st_m}} {bool_lax{$acl_m_u_mi_s_m}} } }
  condition = ${if bool_lax{R_CLIENT}}
  condition = ${if !bool_lax{R_MBA_D}}
  driver = redirect
  data = R_CT_D
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CH_D
  headers_add = R_CH_A
  unseen = true
  redirect_router = backup_router

R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base} }
# the same for all spam_user_ routers
R_CT_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPSpamMailAddress?sub?(objectClass=afUSMTPSpamTarget)} }
R_CH_D == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spam_domain_router:
  condition = ${if or{ {bool_lax{$acl_c_s_st_m}} {bool_lax{$acl_m_u_mi_s_m}} } }
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_D
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CH_D
  headers_add = R_CH_A
  unseen = true
  redirect_router = backup_router

R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base} }
# the same for all spam_user_ routers
R_CT_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPSpamMailAddress?sub?(objectClass=afUSMTPSpamTarget)} }
R_CH_D == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spam_client_router:
  condition = ${if or{ {bool_lax{$acl_c_s_st_m}} {bool_lax{$acl_m_u_mi_s_m}} } }
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_D
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CH_D
  headers_add = R_CH_A
  unseen = true
  redirect_router = backup_router

spam_last_router:
  condition = ${if bool_lax{$acl_m_u_mi_s_m}}
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = :blackhole:
  errors_to = error@services.advancedfiltering.net

# * spamtrap
spamtrap_router:
  condition = ${if bool_lax{$acl_c_s_st_m}}
  driver = redirect
  data = spamtrap@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_SH_D
  headers_add = R_SH_A

# * backup

backup_router:
  driver = redirect
  data = ""
  errors_to = error@services.advancedfiltering.net

R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all backup_user_ routers
R_CT_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPBackupMailAddress?sub?(objectClass=afUSMTPBackupTarget)} }
R_CH_D == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
backup_mailbox_router:
  condition = ${if bool_lax{R_CLIENT}}
  condition = ${if !bool_lax{R_MBA_D}} # unreachable
  driver = redirect
  data = R_CT_D
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CH_D
  headers_add = R_CH_A
  unseen = true
  redirect_router = mx_router

R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base} }
# the same for all backup_user_ routers
R_CT_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPBackupMailAddress?sub?(objectClass=afUSMTPBackupTarget)} }
R_CH_D == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
backup_domain_router:
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_D
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CH_D
  headers_add = R_CH_A
  unseen = true
  redirect_router = mx_router
  
R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base} }
# the same for all backup_user_ routers
R_CT_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPBackupMailAddress?sub?(objectClass=afUSMTPBackupTarget)} }
R_CH_D == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
backup_client_router:
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_D
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CH_D
  headers_add = R_CH_A
  unseen = true
  redirect_router = mx_router

# * mx

mx_router:
  driver = redirect
  data = ""
  errors_to = error@services.advancedfiltering.net

# Router Mail Exchanger Data
R_MX_D = ""

R_LDAP_DN == R_CDM_LDAP_DN
R_MX_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPMXHostName,afUSMTPMXTCPPort,afUSMTPMXAuthUser,afUSMTPMXAuthPassword?sub?(objectClass=afUSMTPMailExchanger)} }
mx_mailbox_router:
  condition = ${if bool_lax{R_CLIENT}}
  condition = ${if !bool_lax{R_MBA_D}} # unreachable
  driver = manualroute
  route_data = ${tr {${map {<\n R_MX_D} {${extract {afUSMTPMXHostName} {$item} }::${extract {afUSMTPMXTCPPort} {$item} }} }} {\n} {:} }
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<\n R_MX_D} {} {$value ${extract {afUSMTPMXHostName} {$item} }_user=${extract {afUSMTPMXAuthUser} {$item} } ${extract {afUSMTPMXHostName} {$item} }_password=${extract {afUSMTPMXAuthPassword} {$item} }}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport

R_LDAP_DN == R_CD_LDAP_DN
R_MX_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPMXHostName,afUSMTPMXTCPPort,afUSMTPMXAuthUser,afUSMTPMXAuthPassword?sub?(objectClass=afUSMTPMailExchanger)} }
mx_domain_router:
  condition = ${if bool_lax{R_CLIENT}}
  driver = manualroute
  route_data = ${tr {${map {<\n R_MX_D} {${extract {afUSMTPMXHostName} {$item} }::${extract {afUSMTPMXTCPPort} {$item} }} }} {\n} {:} }
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<\n R_MX_D} {} {$value ${extract {afUSMTPMXHostName} {$item} }_user=${extract {afUSMTPMXAuthUser} {$item} } ${extract {afUSMTPMXHostName} {$item} }_password=${extract {afUSMTPMXAuthPassword} {$item} }}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport

R_LDAP_DN == R_C_LDAP_DN
R_MX_D == ${lookup ldapm{LDAP_C/ou=settings,R_LDAP_DN?afUSMTPMXHostName,afUSMTPMXTCPPort,afUSMTPMXAuthUser,afUSMTPMXAuthPassword?sub?(objectClass=afUSMTPMailExchanger)} }
mx_client_router:
  condition = ${if bool_lax{R_CLIENT}}
  driver = manualroute
  route_data = ${tr {${map {<\n R_MX_D} {${extract {afUSMTPMXHostName} {$item} }::${extract {afUSMTPMXTCPPort} {$item} }} }} {\n} {:} }
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<\n R_MX_D} {} {$value ${extract {afUSMTPMXHostName} {$item} }_user=${extract {afUSMTPMXAuthUser} {$item} } ${extract {afUSMTPMXHostName} {$item} }_password=${extract {afUSMTPMXAuthPassword} {$item} }}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport

mx_defer_router:
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = bounce@services.advancedfiltering.net
  
# * submission
# (client copy mail, delivery to other addresses)
# the realm should be in the address_data, if not - the leaked bounce (errors_to verification failed)

submission_router:
  condition = R_AD_R_F
  driver = manualroute
  route_data = ${tr {${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_AD_R_LDAP_Q)(afSHostServiceName=submission))} }} {\n} {:} }
  hosts_randomize = true
  transport = submission_transport
  address_data = system_authenticator="true" $address_data
  # loosing a copy mail, bad but is the best solution
  errors_to = error@services.advancedfiltering.net

submission_defer_router:
  condition = R_AD_R_F
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net

begin transports

service_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/ssl/$primary_hostname.crt
  tls_privatekey = /etc/ssl/$primary_hostname.key
  tls_verify_certificates = /etc/ssl/ca
  tls_crl = /etc/ssl/ca
  # no return path fix

submission_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/ssl/$primary_hostname.crt
  tls_privatekey = /etc/ssl/$primary_hostname.key
  tls_verify_certificates = /etc/ssl/ca
  tls_crl = /etc/ssl/ca
  # return path fix (address_data)
  return_path = ${extract {sender} {$address_data} }

# Transport LDAP DN
T_LDAP_DN = ${extract {mx_ldap_dn} {$address_data} }
# Transport Auth-required Hosts
T_AH_D = ${lookup ldap{LDAP_C/afUSMTPMXHostName=${quote_ldap_dn:$host},ou=settings,T_LDAP_DN?afUSMTPMXHostName?base?(afUSMTPMXAuthUser=*)} }
# Transport TLS-required Hosts
T_TH_D = ${lookup ldap{LDAP_C/afUSMTPMXHostName=${quote_ldap_dn:$host},ou=settings,T_LDAP_DN?afUSMTPMXHostName?base?(afUSMTPMXIsTLSRequired=TRUE)} }
# Transport TLS Certificate
T_TLSC = ${lookup ldap{LDAP_C/afUSMTPMXHostName=${quote_ldap_dn:$host},ou=settings,T_LDAP_DN?afUSMTPMXAuthTLSCertificate?base} }
# Transport TLS Key
T_TLSK = ${lookup ldap{LDAP_C/afUSMTPMXHostName=${quote_ldap_dn:$host},ou=settings,T_LDAP_DN?afUSMTPMXAuthTLSKey?base} }
# Transport TLS Verify data, OpenSSL path to root certificates & crls
T_TLSV = ${lookup ldap{LDAP_C/afUSMTPMXHostName=${quote_ldap_dn:$host},ou=settings,T_LDAP_DN?afUSMTPMXAuthTLSCA?base} }

mx_transport:
  driver = smtp
  # mandatory auth & tls
  hosts_require_auth = T_AH_D
  hosts_require_tls = T_TH_D
  # public cert, no verify
  tls_certificate = ${if bool_lax{T_TLSC} {/usr/local/etc/exim/ssl/T_TLSC.crt} {/usr/local/etc/ssl/smtp.services.advancedfiltering.net.crt} }
  tls_privatekey = ${if bool_lax{T_TLSK} {/usr/local/etc/exim/ssl/T_TLSK.key} {/usr/local/etc/ssl/smtp.services.advancedfiltering.net.key} }
  tls_verify_certificates = ${if bool_lax{T_TLSV} {/usr/local/etc/exim/ssl/T_TLSV} fail }
  # return path fix (sender_address)
  return_path = $sender_address
  dkim_domain = dkim.advancedfiltering.net
  dkim_selector = smtp
  dkim_private_key = /usr/local/etc/exim/dkim-smtp.key
  dkim_strict = true
  dkim_sign_headers = From:Sender:Reply-To\
    :Subject\
    :Date:Message-ID\
    :To:Cc\
    :MIME-Version\
    :Content-Type:Content-Transfer-Encoding:Content-ID:Content-Description\
    :Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID\
    :In-Reply-To:References\
    :List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive\
    :X-AdvancedFiltering-Rating

begin retry
^\N[^@]+@test\d+[^\.]*\.hosts\.advancedfiltering\.net$\N * F,5s,1s
services.advancedfiltering.net * F,15m,1m; H,7d,15m,2
* * F,2h,15m; G,16h,1h,1.5; F,4d,6h

begin authenticators

# client_send does not allow ":" in the data
A_USER = ${extract {${host}_user} {$address_data} }
A_PASSWORD = ${extract {${host}_password} {$address_data} }

user_cram_md5_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = cram_md5
  public_name = CRAM-MD5
  client_name = A_USER
  client_secret = A_PASSWORD

user_login_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = plaintext
  public_name = LOGIN
  client_send = :A_USER:A_PASSWORD

user_plain_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = plaintext
  public_name = PLAIN
  client_send = ^A_USER^A_PASSWORD
