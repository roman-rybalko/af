exim_user = advancedfiltering_smtp
exim_group = advancedfiltering_smtp
log_file_path = /usr/local/advancedfiltering/smtp/exim/log/%s.log
process_log_path = /usr/local/advancedfiltering/smtp/exim/exim-process.info
spool_directory = /usr/local/advancedfiltering/smtp/exim/spool
split_spool_directory = true
never_users = root
daemon_smtp_ports = 25 : 137 : 138 : 139 : 445
host_lookup = *
rfc1413_hosts = :
rfc1413_query_timeout = 0s
smtp_receive_timeout = 5s
local_scan_timeout = 5s
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d
tls_advertise_hosts = *
tls_try_verify_hosts = *
tls_certificate = /usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.crt
tls_privatekey = /usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.key
tls_verify_certificates = /usr/local/advancedfiltering/ssl/ca
tls_crl = /usr/local/advancedfiltering/ssl/ca
acl_smtp_connect = connect_acl
acl_smtp_helo = helo_acl
acl_smtp_mail = mail_acl
acl_smtp_rcpt = rcpt_acl
acl_smtp_data = data_acl
received_header_text = Received:\
  ${if def:sender_rcvhost { from $sender_rcvhost}{ from localhost}} by $primary_hostname\
  ${if def:received_protocol { with $received_protocol}}\
  ${if def:tls_cipher { ($tls_cipher)}}\
  ${if def:tls_peerdn { ($tls_peerdn)}}\n \
  id $message_exim_id\
  ${if def:sender_address { (envelope-from <$sender_address>)}}\
  ${if def:received_for { for $received_for}}

# Lightweight Directory Access Protocol Connection
LDAP_C = ldapi://%2fusr%2flocal%2fadvancedfiltering%2fldap%2fldapi
# System LDAP DN
S_LDAP_DN = ou=system,o=advancedfiltering
# System SMTP LDAP DN
S_SMTP_LDAP_DN = afSServiceName=smtp,S_LDAP_DN
# User SMTP LDAP DN
U_SMTP_LDAP_DN = afUServiceName=smtp,ou=user,o=advancedfiltering
# System Realm List (separated by coma)
S_REALM_Lc = ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$primary_hostname},S_LDAP_DN?afSHostRealm?base}}

message_size_limit = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPMaxMessageSize?base}}

begin acl

# System SMTP Trusted Port Data
S_TP_Lc = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPTrustedPort?base}}
# ... Trusted Port Flag
S_TP_F = ${if inlist{$received_port}{<, S_TP_Lc}}
# ... Spam Trap Probability Numerator Data
S_STPN_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPSpamTrapProbabilityNumerator?base}}
# ... Spam Trap Probability Denominator Data
S_STPD_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPSpamTrapProbabilityDenominator?base}}
# ... Spam Trap Flag
S_ST_F = ${if >{S_STPN_D}{${randint:S_STPD_D}}}
# ... Ham Trap Probability Numerator Data
S_HTPN_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPHamTrapProbabilityNumerator?base}}
# ... Ham Trap Probability Denominator Data
S_HTPD_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPHamTrapProbabilityDenominator?base}}
# ... Ham Trap Flag
S_HT_F = ${if >{S_HTPN_D}{${randint:S_HTPD_D}}}
# System MailBox Timeout Data
S_MBTO_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPMailBoxTimeout?base}}
# System MailBox Cutoff Time Data
S_MBCT_D = ${eval10:$tod_epoch-S_MBTO_D}
# System Trusted Message Size
S_TMS_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPTrustedMessageSize?base}}

connect_acl:
  warn
    # System SpamTrap Flag
    set acl_c_s_st_f = S_ST_F
    # System HamTrap Flag
    set acl_c_s_ht_f = S_HT_F
    control = dkim_disable_verify
    #logwrite = DEBUG: tp_f=S_TP_F st_f=$acl_c_s_st_f realms=S_REALM_Lc
  accept
    # smtp_banner
    message = smtp.services.advancedfiltering.net ESMTP${if bool_lax{S_TP_F}{ TP}{}}${if bool_lax{$acl_c_s_st_f}{ ST}{}}${if bool_lax{$acl_c_s_ht_f}{ HT}{}}

helo_acl:
  accept
    message = smtp.services.advancedfiltering.net

# General Black/White List
# accept - match, deny - not match
ldap_bwl_acl:
  warn
    set acl_c_bwl_d = ${lookup ldap{LDAP_C/$acl_c_bwl_ldap_q,$acl_c_bwl_ldap_dn?objectClass,afSMTPBWListIsBlack?base}}
    set acl_c_bl_f = false
    set acl_c_wl_f = false
  accept
    condition = ${extract {afSMTPBWListIsBlack}{$acl_c_bwl_d}{true}{false}}
    # Result
    set acl_c_bl_f = true
    #logwrite = DEBUG: bwl: black
  accept
    condition = ${if bool_lax{$acl_c_bwl_d}}
    set acl_c_wl_f = true
    #logwrite = DEBUG: bwl: white
  deny

# Sender Mail Address Black/White List
# accept - match, deny - not match
sma_bwl_acl:
  warn
    set acl_c_bwl_ldap_q = afSMTPBWListSenderMailAddress=${quote_ldap_dn:$sender_address}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = sender mail address
    #logwrite = DEBUG: sma_bwl
  accept
    # no spf check
    condition = $acl_c_bl_f
  accept
    ! condition = $acl_m_spf_f
    condition = $acl_c_wl_f
  deny
    condition = $acl_m_spf_f
    condition = $acl_c_wl_f
    #logwrite = DEBUG: sma_bwl: SPF fail
  deny

# Certificate Black/White List
# accept - match, deny - not match
cert_bwl_acl:
  deny
    ! condition = ${if bool_lax{$tls_peerdn}}
    #logwrite = DEBUG: cert_bwl: no cert
  warn
    set acl_c_bwl_ldap_q = afSMTPBWListCertificateSubject=${quote_ldap_dn:$tls_peerdn}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = certificate
    #logwrite = DEBUG: cert_bwl ($tls_peerdn)
  accept
    # no certificate verification
    condition = $acl_c_bl_f
  accept
    verify = certificate
    condition = $acl_c_wl_f
  deny
    ! verify = certificate
    condition = $acl_c_wl_f
    #logwrite = DEBUG: cert_bwl: cert verify fail
  deny

# Sender Host Address Black/White List
# accept - match, deny - not match
sha_bwl_acl:
  accept
    set acl_c_bwl_ldap_q = afSMTPBWListHostAddress=${quote_ldap_dn:$sender_host_address}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = sender host address
    #logwrite = DEBUG: sha_bwl
  deny

# Sender Host Name Black/White List
# accept - match, deny - not match
shn_bwl_acl:
  deny
    ! condition = ${if bool_lax{$sender_host_name}}
    #logwrite = DEBUG: shn_bwl: sender host name unknown
  accept
    set acl_c_bwl_ldap_q = afSMTPBWListHostName=${quote_ldap_dn:$sender_host_name}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = sender host name
    #logwrite = DEBUG: shn_bwl
  deny

# Domain Name System Block List
# accept - match, deny - not match
dnsbl_acl:
  deny
    condition = S_TP_F
    set acl_c_bl_f = false
    set acl_c_wl_f = false
    #logwrite = DEBUG: dnsbl: trusted port
  accept
    dnslists = <, ${lookup ldap{LDAP_C/$acl_c_bwl_ldap_dn?afSSMTPDNSBLDomainName?base}}
    set acl_c_bwl_m = DNSBL: $sender_host_address is listed at $dnslist_domain ($dnslist_value: $dnslist_text)
    set acl_c_bl_f = true
    #logwrite = DEBUG: dnsbl
  deny

# Black/White List
# accept - match, deny - not match
bwl_acl:
  accept
    acl = sma_bwl_acl
  accept
    acl = cert_bwl_acl
  accept
    acl = sha_bwl_acl
  accept
    acl = shn_bwl_acl
  accept
    acl = dnsbl_acl
  deny

mail_acl:
  warn
    # SPF Flag
    set acl_m_spf_f = false
    spf = fail
    set acl_m_spf_f = true
    # SPF Msg
    set acl_m_spf_m = $sender_host_address is not allowed to send mail from $sender_address_domain
    #logwrite = DEBUG: spf fail
  warn
    set acl_c_s_wl_f = false
    set acl_c_s_bl_f = false
    set acl_c_bwl_ldap_dn = S_SMTP_LDAP_DN
    acl = bwl_acl
    set acl_c_s_wl_f = $acl_c_wl_f
    set acl_c_s_bl_f = $acl_c_bl_f
    set acl_c_s_bwl_m = system policy: $acl_c_bwl_m
  accept

# User SMTP Realm DN
U_SMTP_R_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+U_SMTP_LDAP_DN
# User SMTP Realm Client DN
U_SMTP_R_C_LDAP_DN = afUClientName=${quote_ldap_dn:$acl_m_u_client},U_SMTP_R_LDAP_DN
# User SMTP Realm Client Domain DN
U_SMTP_R_C_D_LDAP_DN = afUSMTPDomainName=${quote_ldap_dn:$acl_m_u_domain},U_SMTP_R_C_LDAP_DN
# User SMTP Realm Client Domain Mail Box DN
U_SMTP_R_C_D_MB_LDAP_DN = afUSMTPDMBLocalPart=${quote_ldap_dn:$local_part},U_SMTP_R_C_D_LDAP_DN

# * определяем имя домена по синониму
domain_rcpt_acl:
  # ** домен => user_domain
  accept
    # User Domain
    set acl_m_u_domain = ${lookup ldap{LDAP_C/afUSMTPDomainName=${quote_ldap_dn:$domain},U_SMTP_R_C_LDAP_DN?afUSMTPDomainName?base}}
    condition = ${if bool_lax{$acl_m_u_domain}}
    #logwrite = DEBUG: acl_m_u_domain=$acl_m_u_domain
  # ** синоним => user_domain
  accept
    set acl_m_u_domain = ${lookup ldap{LDAP_C/U_SMTP_R_C_LDAP_DN?afUSMTPDomainName?sub?(&(objectClass=afUSMTPDomain)(afUSMTPDomainAliasName=${quote_ldap:$domain}))}}
    condition = ${if bool_lax{$acl_m_u_domain}}
    #logwrite = DEBUG: acl_m_u_domain=$acl_m_u_domain (alias)
  # ** не найден в ou=user => 4xx Replicating, please try again later
  defer
    message = Replicating, please try again later

# Lookup recipient configuration option
# accept - found, deny - not found
conf_rcpt_acl:
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_SMTP_R_C_D_MB_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{$acl_m_u_conf_value}{}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_SMTP_R_C_D_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{$acl_m_u_conf_value}{}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_SMTP_R_C_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{$acl_m_u_conf_value}{}}
  deny

# Black/White List for recipient
# accept - match, deny - not match
bwl_rcpt_acl:
  accept
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_MB_LDAP_DN
    acl = bwl_acl
    # Black/White List Recipient Msg
    set acl_m_bwl_rcpt_m = user recipient policy
  accept
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_LDAP_DN
    acl = bwl_acl
    set acl_m_bwl_rcpt_m = user domain policy
  accept
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_LDAP_DN
    acl = bwl_acl
    set acl_m_bwl_rcpt_m = user policy
  deny

# User SMTP MailBox Data
U_SMTP_MB_D = ${lookup ldap{LDAP_C/U_SMTP_R_C_D_MB_LDAP_DN?objectClass,afUSMTPDMBIsAbsent?base?(afUSMTPDMBTimeUpdated>=S_MBCT_D)}}

rcpt_acl:
  # * recipients_count > 0 => 4xx Mail box is temporarily unavailable, please try again later
  defer
    condition = ${if bool_lax{$recipients_count}}
    message = Mail box is temporarily unavailable, please try again later

  # * проверка realm для домена
  # ** нет домена => 5xx The domain is not in service, stop
  deny
    # User Client (name/id)
    set acl_m_u_client = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
    #logwrite = DEBUG: acl_m_u_client=$acl_m_u_client
    ! condition = ${if bool_lax{$acl_m_u_client}}
    message = The domain is not in service
  # ** чужой realm => 4xx Moved, try another host, stop
  defer
    # User Realm
    set acl_m_u_realm = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:$acl_m_u_client},S_LDAP_DN?afSClientRealm?base}}
    #logwrite = DEBUG: acl_m_u_realm=$acl_m_u_realm
    ! condition = ${if inlist{$acl_m_u_realm}{<, S_REALM_Lc}}
    message = Moved, try another host
  # * определяем имя домена по синониму
  require
    acl = domain_rcpt_acl

  # * получение пользовательской настройки user_nombxchk (NoMailBoxCheck - no auto-add)
  warn
    set acl_m_u_nombxchk_f = false
    set acl_m_u_conf_name = afUSMTPNoMailBoxCheck
    acl = conf_rcpt_acl
    set acl_m_u_nombxchk_f = $acl_m_u_conf_value

  # * проверка адреса получателя в afMailBox (с учетом MailBox Timeout)
  # ** absent && sys_spamtrap => 2xx SST/MBA Mail box does not exist, flag_mb_absent, stop
  accept
    condition = $acl_c_s_st_f
    condition = ${extract {afUSMTPDMBIsAbsent}{U_SMTP_MB_D}{true}{false}}
    set acl_m_u_absent = true
    message = SST/MBA Mail box does not exist
  # ** absent => 5xx Mail box does not exist, stop
  deny
    condition = ${extract {afUSMTPDMBIsAbsent}{U_SMTP_MB_D}{true}{false}}
    message = Mail box does not exist
  # ** (expired || not_found) && user_nombxchk && sys_spamtrap => 2xx UNMBC,SST/MBA Mail box does not exist, flag_mb_absent, stop
  accept
    condition = $acl_c_s_st_f
    condition = $acl_m_u_nombxchk_f
    # existing
    ! condition = ${extract {objectClass}{U_SMTP_MB_D}{true}{false}}
    set acl_m_u_absent = true
    message = UNMBC,SST/MBA Mail box does not exist
  # ** (expired || not_found) && user_nombxchk => 5xx UNMBC/ Mail box does not exist, stop
  deny
    condition = $acl_m_u_nombxchk_f
    # existing
    ! condition = ${extract {objectClass}{U_SMTP_MB_D}{true}{false}}
    message = UNMBC/ Mail box does not exist
  # ** expired || not_found => 4xx Your data is verifying, please try again later, log, stop
  defer
    # existing
    ! condition = ${extract {objectClass}{U_SMTP_MB_D}{true}{false}}
    message = Your data is verifying, please try again later
    logwrite = AdvancedFiltering:NewMailBox:<$local_part>Domain:<$acl_m_u_domain>Client:<$acl_m_u_client>Realm:<$acl_m_u_realm>
  # ** ok

  # * получение пользовательской настройки user_spt (Spam PassThrough)
  warn
    set acl_m_u_spt_f = false
    set acl_m_u_conf_name = afUSMTPSpamPassthrough
    acl = conf_rcpt_acl
    set acl_m_u_spt_f = $acl_m_u_conf_value

  # * проверка пользовательских списков фильтрации => flag_user_wl, flag_user_bl, msg_user_wbl
  warn
    set acl_m_u_wl_f = false
    set acl_m_u_bl_f = false
    acl = bwl_rcpt_acl
    set acl_m_u_wl_f = $acl_c_wl_f
    set acl_m_u_bl_f = $acl_c_bl_f
    set acl_m_u_bwl_m = $acl_m_bwl_rcpt_m: $acl_c_bwl_m

  # * flag_user_wl => 2xx UWL/ ($msg_user_wbl), stop
  accept
    condition = $acl_m_u_wl_f
    message = UWL/ ($acl_m_u_bwl_m)

  # * flag_user_bl => 5xx UBL/ ($msg_user_wbl), stop
  deny
    condition = $acl_m_u_bl_f
    message = UBL/ ($acl_m_u_bwl_m)

  # * flag_sys_wl => 2xx SWL/ ($msg_sys_wbl), stop
  accept
    condition = $acl_c_s_wl_f
    message = SWL/ ($acl_c_s_bwl_m)

  # * flag_sys_bl && !sys_spamtrap && !user_spt => 5xx SBL/ ($msg_sys_wbl), stop
  deny
    condition = $acl_c_s_bl_f
    ! condition = $acl_c_s_st_f
    ! condition = $acl_m_u_spt_f
    message = SBL/ ($acl_c_s_bwl_m)

  # * flag_sys_bl => 2xx SBL,(SST|USPT)/ ($msg_sys_wbl), stop
  accept
    condition = $acl_c_s_bl_f
    message = SBL,(SST|USPT)/ ($acl_c_s_bwl_m)

  # * flag_spf && !user_spt && !sys_spamtrap => 5xx SPF/ (SPF: ...), stop
  deny
    condition = $acl_m_spf_f
    ! condition = $acl_m_u_spt_f
    ! condition = $acl_c_s_st_f
    message = SPF/ (SPF: $acl_m_spf_m)

  # * flag_spf => 2xx SPF,(USPT|SST)/ (SPF: ...), stop
  accept
    condition = $acl_m_spf_f
    message = SPF,(USPT|SST)/ (SPF: $acl_m_spf_m)

  # * ok
  accept

# Message Incoming Header
U_MI_H_D = $rheader_message-id:
# Message Incoming Fix 1
U_MI_F1 = ${sg{U_MI_H_D}{^\\s+}{}}
# Message Incoming Fix 2
U_MI_F2 = ${sg{U_MI_F1}{\\s+\$}{}}
U_MI_F3 = ${sg{U_MI_F2}{^[^\<]*\<}{}}
U_MI_F4 = ${sg{U_MI_F3}{\>[^\>]*\$}{}}
U_MI_F5 = ${str2b64:U_MI_F4}
U_MI_F6 = ${tr{U_MI_F5}{/+=}{.-_}}
# Message Incoming Data
U_MI_D = U_MI_F6

# User SMTP DataBase LDAP DN
U_SMTPDB_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+afUServiceName=smtpdb,ou=user,o=advancedfiltering

# User SMTP DB Message Incoming
U_SMTPDB_MI_spam_D = ${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:U_MI_D},U_SMTPDB_LDAP_DN?afUSMTPMessageSpamDescription?base}}
U_SMTPDB_MI_sender_D = ${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:U_MI_D},U_SMTPDB_LDAP_DN?afUSMTPMessageSenderMailAddress?base}}

# Message Outgoing Header(s)
U_MO_H_D = $bheader_in-reply-to: $bheader_references:
# Message Outgoing Fix 1
U_MO_F1 = ${sg{U_MO_H_D}{^\\s+}{}}
# Message Outgoing Fix 2
U_MO_F2 = ${sg{U_MO_F1}{\\s+\$}{}}
U_MO_F3 = ${sg{U_MO_F2}{^[^\<]*\<}{}}
U_MO_F4 = ${sg{U_MO_F3}{\>[^\>]*\$}{}}
U_MO_F5 = ${sg{U_MO_F4}{\>[^\<\>]*\<}{\<}}
U_MO_F6 = ${map {<\< U_MO_F5} {${str2b64:$item}}}
U_MO_F7 = ${tr{U_MO_F6}{/+=}{.-_}}
U_MO_F8 = ${sg{U_MO_F7}{\<}{:}}
# Message Outgoing List
U_MO_L = U_MO_F8

# User Submission DataBase LDAP DN
U_SDB_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+afUServiceName=sdb,ou=user,o=advancedfiltering

# User SDB Message Outgoing
U_SDB_MO_sender_L = ${map{U_MO_L}{${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:$item},U_SDB_LDAP_DN?afUSMTPMessageSenderMailAddress?base}}}}

data_acl:
  # * flag_mb_absent => fake/5xx MBA/ST Mail box does not exist, stop, flag_spamtrap
  accept
    condition = ${if bool_lax{$acl_m_u_absent}}
    set acl_m_spamtrap_f = true
    control = fakereject/MBA/ST Mail box does not exist

  # * flag_user_wl => 2xx UWL/ ($msg_user_wbl), stop
  accept
    condition = $acl_m_u_wl_f
    message = UWL/ ($acl_m_u_bwl_m) id=$message_exim_id

  # * flag_sys_wl => 2xx SWL/ ($msg_sys_wbl), stop
  accept
    condition = $acl_c_s_wl_f
    message = SWL/ ($acl_c_s_bwl_m) id=$message_exim_id

  # * flag_sys_bl && user_spt => 2xx SBL,USPT/ST,S ($msg_sys_wbl), stop, flag_spamtrap, flag_spam
  accept
    condition = $acl_c_s_bl_f
    condition = $acl_m_u_spt_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = SBL,USPT/ST,S ($acl_c_s_bwl_m) id=$message_exim_id

  # * flag_sys_bl => fake/5xx SBL/ST,S ($msg_sys_wbl), stop, flag_spamtrap, flag_spam
  accept
    condition = $acl_c_s_bl_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    control = fakereject/SBL/ST,S ($acl_c_s_bwl_m) id=$message_exim_id

  # * flag_spf && user_spt => 2xx SPF,USPT/ST,S (SPF: ...), stop, flag_spamtrap, flag_spam
  accept
    condition = $acl_m_spf_f
    condition = $acl_m_u_spt_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = SPF,USPT/ST,S (SPF: $acl_m_spf_m) id=$message_exim_id

  # * flag_spf => fake/5xx SPF/ST,S (SPF: ...), stop, log Message-ID, flag_spamtrap, flag_spam
  accept
    condition = $acl_m_spf_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    control = fakereject/SPF/ST,S (SPF: $acl_m_spf_m) id=$message_exim_id

  # * проверка Message-Id в afMessageIncoming
  # ** нет MessageId && user_spt => 2xx USPT/S (No Message-ID header), stop, flag_spam
  accept
    ! condition = ${if bool_lax{U_MI_H_D}}
    condition = $acl_m_u_spt_f
    set acl_m_spam_f = true
    message = USPT/S (No Message-ID header)
  # ** нет MessageId => 5xx Malformed (No Message-ID header), stop
  deny
    ! condition = ${if bool_lax{U_MI_H_D}}
    message = Malformed (No Message-ID header)
  # ** ok, afIsSpam && user_spt => 2xx USPT/S ($afSpamDescription), stop, flag_spam
  accept
    condition = ${if bool_lax{U_SMTPDB_MI_spam_D}}
    condition = $acl_m_u_spt_f
    set acl_m_spam_f = true
    message = USPT/S (U_SMTPDB_MI_spam_D)
  # ** ok, afIsSpam => 5xx Spam ($afSpamDescription), stop
  deny
    condition = ${if bool_lax{U_SMTPDB_MI_spam_D}}
    message = Spam (U_SMTPDB_MI_spam_D)
  # ** не совпадает sender && user_spt => 2xx USPT/ST,S (Several senders for the same message), stop, flag_spamtrap, flag_spam
  accept
    ! condition = ${if eqi{U_SMTPDB_MI_sender_D}{$sender_address}}
    condition = $acl_m_u_spt_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = USPT/ST,S (Several senders for the same message)
  # ** не совпадает sender && sys_spamtrap => fake/5xx SST/ST,S (Several senders for the same message), stop, flag_spamtrap, flag_spam
  accept
    ! condition = ${if eqi{U_SMTPDB_MI_sender_D}{$sender_address}}
    condition = $acl_c_s_st_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    control = fakereject/SST/ST,S (Several senders for the same message) id=$message_exim_id
  # ** не совпадает sender => 5xx Bad sender (Several senders for the same message), stop
  deny
    ! condition = ${if eqi{U_SMTPDB_MI_sender_D}{$sender_address}}
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = Bad sender (Several senders for the same message)
  # ** ok => ok, stop
  accept
    condition = ${if bool_lax{U_SMTPDB_MI_sender_D}}

  # * проверка In-Reply-To, References в afMessageOutgoing
  # ** ok => 2xx /HT, stop, flag_hamtrap
  accept
    condition = ${if bool_lax{U_MO_H_D}}
    #logwrite = DEBUG: realm: $acl_m_u_realm
    #logwrite = DEBUG: references: U_MO_L
    #logwrite = DEBUG: senders: U_SDB_MO_sender_L
    #logwrite = DEBUG: recipient: $recipients
    # $recipients has a single value
    condition = ${if forany{U_SDB_MO_sender_L}{eqi{$item}{$recipients}}}
    set acl_m_hamtrap_f = true
    message = /HT id=$message_exim_id

  # * message_size >= sys_trustedmessagesize
  # ** ok => 2xx TMS/, stop
  accept
    condition = ${if >{$message_size}{S_TMS_D}}
    message = TMS/ id=$message_exim_id

  # * 4xx /MP Your data is verifying, please try again later, flag_mailproc
  accept
    set acl_m_mailproc_f = true
    control = fakedefer//MP Your data is verifying, please try again later

begin routers

# Router Client
R_CLIENT = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
# Router Client Realm
R_C_REALM = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:R_CLIENT},S_LDAP_DN?afSClientRealm?base}}

# (is needed for service_* routers and submission_* routers)
# Router Address_Data Realm LDAP Query (needed for service_* routers and submission_* routers)
R_AD_R_LDAP_Q = afSHostRealm=${quote_ldap_dn:${extract {realm} {$address_data} }}
# Router Address_Data Realm Flag
R_AD_R_F = ${extract {realm} {$address_data} }
# Router System Realm LDAP Query
R_SYS_R_LDAP_Q = ${reduce {S_REALM_Lc} {|} {$value(afSHostRealm=${quote_ldap_dn:$item})} }
# Router Services Realm LDAP Q
R_S_R_LDAP_Q = ${if bool_lax{R_AD_R_F} {R_AD_R_LDAP_Q} {R_SYS_R_LDAP_Q} }

# * service

# errors_to addresses need to be verified
service_verify_router:
  verify_only = true
  domains = services.advancedfiltering.net
  driver = accept

# Routers/Service Router Route Data Hosts List (separated by \n)
R_SRRD_H_Lnl = ${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_S_R_LDAP_Q)(afSHostServiceName=$local_part))}}
# Routers/Service Router Route Data Address (uses $item)
R_SRRD_address_I = ${lookup ldap{LDAP_C/afSHostServiceName=$local_part,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceHostAddress?base}}
# Routers/Service Router Route Data Port (uses $item)
R_SRRD_port_I = ${lookup ldap{LDAP_C/afSHostServiceName=$local_part,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceTCPPort?base}}
# Routers/Service Router Route Data List (separated by \n)
R_SRRD_Lnl = ${map{<\n R_SRRD_H_Lnl}{${if bool_lax{R_SRRD_address_I}{R_SRRD_address_I}{$item}}${if bool_lax{R_SRRD_port_I}{:R_SRRD_port_I}{}}}}

service_router:
  domains = services.advancedfiltering.net
  driver = manualroute
  debug_print = address_data = $address_data, sys_r = R_SYS_R_LDAP_Q
  route_data = ${if bool_lax{R_SRRD_Lnl}{\"<\n R_SRRD_Lnl\"}{}}
  hosts_randomize = true
  transport = service_transport
  address_data = system_authenticator="true" $address_data
  # error delivery loop prevention
  errors_to = ${if eqi{$local_part}{error}{}{error@services.advancedfiltering.net}}
  self = send

service_defer_router:
  domains = services.advancedfiltering.net
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net

# Router Services Headers Delete List
R_SHD_L = X-AdvancedFiltering-Sender:X-AdvancedFiltering-Recipient:X-AdvancedFiltering-Recipients:X-AdvancedFiltering-Realms
# Router Services Headers Add List (separated by \n)
R_SHA_Lnl = X-AdvancedFiltering-Sender: $sender_address\nX-AdvancedFiltering-Recipient: $local_part@$domain

# * mailproc
mailproc_router:
  condition = $acl_m_mailproc_f
  driver = redirect
  data = mailproc@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_SHD_L
  headers_add = R_SHA_Lnl

# * hamtrap
hamtrap_router:
  condition = $acl_c_s_ht_f
  condition = $acl_m_hamtrap_f
  driver = redirect
  data = hamtrap@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_SHD_L
  headers_add = R_SHA_Lnl
  unseen = true

# * spamtrap
spamtrap_router:
  condition = $acl_c_s_st_f
  condition = $acl_m_spamtrap_f
  driver = redirect
  data = spamtrap@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_SHD_L
  headers_add = R_SHA_Lnl
  unseen = true

# * user_absent
user_absent_router:
  condition = $acl_m_u_absent
  driver = redirect
  data = :blackhole:
  errors_to = error@services.advancedfiltering.net

# Router Client LDAP DN
R_C_LDAP_DN = afUClientName=${quote_ldap_dn:R_CLIENT},afUServiceRealm=${quote_ldap_dn:R_C_REALM}+U_SMTP_LDAP_DN
# Router Client Domain LDAP DN
R_CD_LDAP_DN = afUSMTPDomainName=${quote_ldap_dn:$domain},R_C_LDAP_DN
# Router Client Domain Mail Box LDAP DN
R_CDM_LDAP_DN = afUSMTPDMBLocalPart=${quote_ldap_dn:$local_part},R_CD_LDAP_DN
# Router MailBox Absent Data
R_MBA_D = ${lookup ldap{LDAP_C/R_CDM_LDAP_DN?afUSMTPDMBIsAbsent?base}}

# *************************************************************************************************

# same contents for all spam_* and backup_* routers
# (except condition clause)

# *************************************************************************************************

# Router General LDAP DN
R_LDAP_DN = ""

# Router Copy Target List (separated by coma)
R_CT_Lc = ""

# Router Copy Sender Data
R_CS_D = ""

# Router Copy Headers Delete List
# X-AdvancedFiltering-Sender-XXX header for separate batch
R_CHD_L = X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-XXX
# Router Copy Headers Add List (separated by \n)
R_CHA_Lnl = X-AdvancedFiltering-Return-Path: $sender_address\nX-AdvancedFiltering-Envelope-To: $local_part@$domain

# * spamaddress

R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all spamaddress_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spamaddress_mailbox_router:
  condition = $acl_m_spam_f
  # for data, R_MBA_D
  condition = ${if bool_lax{R_CLIENT}}
  condition = ${if !bool_lax{R_MBA_D}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = spambox_router

R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base}}
# the same for all spamaddress_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spamaddress_domain_router:
  condition = $acl_m_spam_f
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = spambox_router

R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base}}
# the same for all spamaddress_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spamaddress_client_router:
  condition = $acl_m_spam_f
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = spambox_router

# * spambox

spambox_router:
  driver = redirect
  data = ""
  errors_to = error@services.advancedfiltering.net

# Router Copy Target Data
R_CT_D = ""

R_LDAP_DN == R_CDM_LDAP_DN
# the same for all spambox_ routers
R_CT_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailBox?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spambox_mailbox_router:
  condition = $acl_m_spam_f
  # for data, R_MBA_D
  condition = ${if bool_lax{R_CLIENT}}
  condition = ${if !bool_lax{R_MBA_D}}
  driver = redirect
  data = R_CT_D+$local_part@$domain
  address_data = sender=$sender_address realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = user_spam_block_router

R_LDAP_DN == R_CD_LDAP_DN
# the same for all spambox_ routers
R_CT_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailBox?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spambox_domain_router:
  condition = $acl_m_spam_f
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_D+$local_part@$domain
  address_data = sender=$sender_address realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = user_spam_block_router

R_LDAP_DN == R_C_LDAP_DN
# the same for all spambox_ routers
R_CT_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailBox?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
spambox_client_router:
  condition = $acl_m_spam_f
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_D+$local_part@$domain
  address_data = sender=$sender_address realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = user_spam_block_router

# не пропускаем спам если !user_spt
user_spam_block_router:
  condition = ${if !bool_lax{$acl_m_u_spt_f}}
  condition = $acl_m_spam_f
  driver = redirect
  data = :blackhole:
  errors_to = error@services.advancedfiltering.net

# * backup

R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPBackupMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
backup_mailbox_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  # unreachable
  condition = ${if !bool_lax{R_MBA_D}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = spam_block_router

R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base}}
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPBackupMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
backup_domain_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = spam_block_router

R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base}}
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPBackupMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
backup_client_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  unseen = true
  redirect_router = spam_block_router

# не пропускаем спам
spam_block_router:
  condition = $acl_m_spam_f
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = :blackhole:
  errors_to = error@services.advancedfiltering.net

# * redirect

R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all redirect_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPRedirectMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
redirect_mailbox_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  # unreachable
  condition = ${if !bool_lax{R_MBA_D}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  redirect_router = user_spam_block_router

R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base}}
# the same for all redirect_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPRedirectMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
redirect_domain_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  redirect_router = user_spam_block_router

R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base}}
# the same for all redirect_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPRedirectMailAddress?base}}
R_CHD_L == X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To:X-AdvancedFiltering-Sender-${str2b64:R_CS_D}
redirect_client_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  headers_remove = R_CHD_L
  headers_add = R_CHA_Lnl
  redirect_router = user_spam_block_router

# * mx

# Routers/Mail Exchanger Name List (separated by coma)
R_MX_N_Lc = ""
# Routers/Mail Exchanger Address (uses $item)
R_MX_address_I = ""
# Routers/Mail Exchanger Port (uses $item)
R_MX_port_I = ""
# Routers/Mail Exchanger Address:Port (uses $item)
R_MX_address_port_I = ""
# Routers/Mail Exchanger User (uses $item)
R_MX_user_I = ""
# Routers/Mail Exchanger Password (uses $item)
R_MX_password_I = ""
# Routers/Mail Exchanger List (separated by coma)
R_MX_Lc = ""

R_LDAP_DN == R_CDM_LDAP_DN
R_MX_N_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPMXName?base}}
R_MX_address_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXHostName?base}}
R_MX_port_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXTCPPort?base}}
R_MX_user_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthUser?base}}
R_MX_password_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthPassword?base}}
R_MX_address_port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I}{$item}}${if bool_lax{R_MX_port_I}{:R_MX_port_I}{}}
R_MX_Lc == ${map{<, R_MX_N_Lc}{R_MX_address_port_I}}
mx_mailbox_router:
  # for data, R_MBA_D
  condition = ${if bool_lax{R_CLIENT}}
  # unreachable
  condition = ${if !bool_lax{R_MBA_D}}
  driver = manualroute
  route_data = ${if bool_lax{R_MX_Lc}{\"<, R_MX_Lc\"}{}}
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<, R_MX_N_Lc} {} {$value R_MX_address_port_I/user=R_MX_user_I R_MX_address_port_I/password=R_MX_password_I R_MX_address_port_I/name=$item}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport
  self = send

R_LDAP_DN == R_CD_LDAP_DN
R_MX_N_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPMXName?base}}
R_MX_address_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXHostName?base}}
R_MX_port_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXTCPPort?base}}
R_MX_user_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthUser?base}}
R_MX_password_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthPassword?base}}
R_MX_address_port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I}{$item}}${if bool_lax{R_MX_port_I}{:R_MX_port_I}{}}
R_MX_Lc == ${map{<, R_MX_N_Lc}{R_MX_address_port_I}}
mx_domain_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = manualroute
  route_data = ${if bool_lax{R_MX_Lc}{\"<, R_MX_Lc\"}{}}
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<, R_MX_N_Lc} {} {$value R_MX_address_port_I/user=R_MX_user_I R_MX_address_port_I/password=R_MX_password_I R_MX_address_port_I/name=$item}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport
  self = send

R_LDAP_DN == R_C_LDAP_DN
R_MX_N_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPMXName?base}}
R_MX_address_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXHostName?base}}
R_MX_port_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXTCPPort?base}}
R_MX_user_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthUser?base}}
R_MX_password_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthPassword?base}}
R_MX_address_port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I}{$item}}${if bool_lax{R_MX_port_I}{:R_MX_port_I}{}}
R_MX_Lc == ${map{<, R_MX_N_Lc}{R_MX_address_port_I}}
mx_client_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = manualroute
  route_data = ${if bool_lax{R_MX_Lc}{\"<, R_MX_Lc\"}{}}
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<, R_MX_N_Lc} {} {$value R_MX_address_port_I/user=R_MX_user_I R_MX_address_port_I/password=R_MX_password_I R_MX_address_port_I/name=$item}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport
  self = send

mx_defer_router:
  # for data
  condition = ${if bool_lax{R_CLIENT}}
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = bounce@services.advancedfiltering.net

# * submission
# (client copy mail, delivery to other addresses)
# the realm should be in the address_data, if not - the leaked bounce (errors_to verification failed)

# Routers/Submission Router Route Data Hosts List
R_SubRRD_H_Lnl = ${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_AD_R_LDAP_Q)(afSHostServiceName=submission))}}
# Routers/Submission Router Route Data Address (uses $item)
R_SubRRD_address_I = ${lookup ldap{LDAP_C/afSHostServiceName=submission,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceHostAddress?base}}
# Routers/Submission Router Route Data Port (uses $item)
R_SubRRD_port_I = ${lookup ldap{LDAP_C/afSHostServiceName=submission,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceTCPPort?base}}
# Routers/Submission Router Route Data List
R_SubRRD_Lnl = ${map{<\n R_SubRRD_H_Lnl}{${if bool_lax{R_SubRRD_address_I}{R_SubRRD_address_I}{$item}}${if bool_lax{R_SubRRD_port_I}{:R_SubRRD_port_I}{}}}}

submission_router:
  condition = R_AD_R_F
  driver = manualroute
  route_data = ${if bool_lax{R_SubRRD_Lnl}{\"<\n R_SubRRD_Lnl\"}{}}
  hosts_randomize = true
  transport = submission_transport
  address_data = system_authenticator="true" $address_data
  # loosing a copy mail, bad but is the best solution
  errors_to = error@services.advancedfiltering.net
  self = send

submission_defer_router:
  condition = R_AD_R_F
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net

begin transports

service_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/advancedfiltering_ssl/$primary_hostname.crt
  tls_privatekey = /etc/advancedfiltering_ssl/$primary_hostname.key
  tls_verify_certificates = /etc/advancedfiltering_ssl/ca
  tls_crl = /etc/advancedfiltering_ssl/ca
  # no return path fix

submission_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/advancedfiltering_ssl/$primary_hostname.crt
  tls_privatekey = /etc/advancedfiltering_ssl/$primary_hostname.key
  tls_verify_certificates = /etc/advancedfiltering_ssl/ca
  tls_crl = /etc/advancedfiltering_ssl/ca
  # return path fix (address_data)
  return_path = ${extract {sender} {$address_data} }

# Transport LDAP DN
T_LDAP_DN = ${extract {mx_ldap_dn} {$address_data} }
# Transport Mail eXchanger Name Data
T_MXN_D = ${extract {$host${if bool_lax{$smtp_host_specific_port}{:$smtp_host_specific_port}{}}/name} {$address_data} }
# Transport Auth-required Hosts
T_AH_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXHostName?base?(afUSMTPMXAuthUser=*)} }
# Transport TLS-required Hosts
T_TH_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXHostName?base?(afUSMTPMXTLSRequired=TRUE)} }
# Transport TLS Certificate
T_TLSC_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXAuthTLSCertificate?base}}
# Transport TLS Key
T_TLSK_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXAuthTLSKey?base}}
# Transport TLS Verify data, OpenSSL path to root certificates & crls
T_TLSV_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXAuthTLSCA?base}}

mx_transport:
  driver = smtp
  # mandatory auth & tls
  hosts_require_auth = T_AH_D
  hosts_require_tls = T_TH_D
  # public cert, no verify
  tls_certificate = ${if bool_lax{T_TLSC_D} {/usr/local/advancedfiltering/smtp/ssl/T_TLSC_D.crt} {/usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.crt} }
  tls_privatekey = ${if bool_lax{T_TLSK_D} {/usr/local/advancedfiltering/smtp/ssl/T_TLSK_D.key} {/usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.key} }
  tls_verify_certificates = ${if bool_lax{T_TLSV_D} {/usr/local/advancedfiltering/smtp/ssl/T_TLSV_D} fail }
  # return path fix (sender_address)
  return_path = $sender_address
  dkim_domain = dkim.advancedfiltering.net
  dkim_selector = smtp
  dkim_private_key = /usr/local/advancedfiltering/smtp/dkim-smtp.key
  dkim_strict = true
  dkim_sign_headers = X-AdvancedFiltering-Return-Path:X-AdvancedFiltering-Envelope-To

begin retry

# DEBUG
^\N[^@]+@test\-smtp\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@w01\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@w02\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@h01\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@h02\.hosts\.advancedfiltering\.net$\N * F,5s,1s

services.advancedfiltering.net * F,15m,1m; H,7d,15m,2
bounce@services.advancedfiltering.net * F,15m,1m; F,1d,15m

* rcpt_4xx F,1m,5s; F,15m,1m; F,1h,15m; F,1d,1h
* * F,15m,1m; F,1h,15m; F,1d,1h

begin authenticators

# client_send does not allow ":" in the data
A_USER = ${extract {$host{if bool_lax{$smtp_host_specific_port}{:$smtp_host_specific_port}{}}/user} {$address_data} }
A_PASSWORD = ${extract {$host{if bool_lax{$smtp_host_specific_port}{:$smtp_host_specific_port}{}}/password} {$address_data} }

user_cram_md5_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = cram_md5
  public_name = CRAM-MD5
  client_name = A_USER
  client_secret = A_PASSWORD

user_login_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = plaintext
  public_name = LOGIN
  client_send = :A_USER:A_PASSWORD

user_plain_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = plaintext
  public_name = PLAIN
  client_send = ^A_USER^A_PASSWORD
