exim_user = advancedfiltering_smtp
exim_group = advancedfiltering_smtp
log_file_path = /usr/local/advancedfiltering/smtp/exim/log/%s.log
process_log_path = /usr/local/advancedfiltering/smtp/exim/exim-process.info
spool_directory = /usr/local/advancedfiltering/smtp/exim/spool
split_spool_directory = true
never_users = root
daemon_smtp_ports = 25 : 137 : 138 : 139 : 445
host_lookup = *
rfc1413_hosts = :
rfc1413_query_timeout = 0s
smtp_receive_timeout = 5s
local_scan_timeout = 5s
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d
tls_advertise_hosts = *
tls_try_verify_hosts = *
tls_certificate = /usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.crt
tls_privatekey = /usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.key
tls_verify_certificates = /usr/local/advancedfiltering/ssl/ca
tls_crl = /usr/local/advancedfiltering/ssl/ca
acl_smtp_connect = connect_acl
acl_smtp_helo = helo_acl
acl_smtp_mail = mail_acl
acl_smtp_rcpt = rcpt_acl
acl_smtp_dkim = dkim_acl
acl_smtp_data = data_acl
received_header_text = Received:\
  ${if def:sender_rcvhost { from $sender_rcvhost}{ from localhost}} by $primary_hostname\
  ${if def:received_protocol { with $received_protocol}}\
  ${if def:tls_cipher { ($tls_cipher)}}\
  ${if def:tls_peerdn { ($tls_peerdn)}}\n \
  id $message_exim_id\
  ${if def:sender_address { (envelope-from <$sender_address>)}}\
  ${if def:received_for { for $received_for}}
dkim_verify_signers = dkim.advancedfiltering.net

# Lightweight Directory Access Protocol Connection
LDAP_C = ldapi://%2fusr%2flocal%2fadvancedfiltering%2fldap%2fldapi
# System LDAP DN
S_LDAP_DN = ou=system,o=advancedfiltering
# System SMTP LDAP DN
S_SMTP_LDAP_DN = afSServiceName=smtp,S_LDAP_DN
# User SMTP LDAP DN
U_SMTP_LDAP_DN = afUServiceName=smtp,ou=user,o=advancedfiltering
# System Realm List (separated by coma)
S_REALM_Lc = ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$primary_hostname},S_LDAP_DN?afSHostRealm?base}}

message_size_limit = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPMaxMessageSize?base}}

begin acl

# System SMTP Trusted Port Data
S_TP_Lc = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPTrustedPort?base}}
# ... Trusted Port Flag
S_TP_F = ${if inlist{$received_port}{<, S_TP_Lc}}
# ... Spam Trap Probability Numerator Data
S_STPN_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPSpamTrapProbabilityNumerator?base}}
# ... Spam Trap Probability Denominator Data
S_STPD_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPSpamTrapProbabilityDenominator?base}}
# ... Spam Trap Flag
S_ST_F = ${if >{S_STPN_D}{${randint:S_STPD_D}}}
# ... Ham Trap Probability Numerator Data
S_HTPN_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPHamTrapProbabilityNumerator?base}}
# ... Ham Trap Probability Denominator Data
S_HTPD_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPHamTrapProbabilityDenominator?base}}
# ... Ham Trap Flag
S_HT_F = ${if >{S_HTPN_D}{${randint:S_HTPD_D}}}
# System MailBox Timeout Data
S_MBTO_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPMailBoxTimeout?base}}
# System MailBox Cutoff Time Data
S_MBCT_D = ${eval10:$tod_epoch-S_MBTO_D}
# System Trusted Message Size
S_TMS_D = ${lookup ldap{LDAP_C/S_SMTP_LDAP_DN?afSSMTPTrustedMessageSize?base}}

connect_acl:
  warn
    # System SpamTrap Flag
    set acl_c_s_st_f = S_ST_F
    # System HamTrap Flag
    set acl_c_s_ht_f = S_HT_F
    control = dkim_disable_verify
    #logwrite = DEBUG: tp_f=S_TP_F st_f=$acl_c_s_st_f realms=S_REALM_Lc
  accept
    # smtp_banner
    message = smtp.services.advancedfiltering.net ESMTP${if bool_lax{S_TP_F}{ TP}{}}${if bool_lax{$acl_c_s_st_f}{ ST}{}}${if bool_lax{$acl_c_s_ht_f}{ HT}{}}

helo_acl:
  accept
    message = smtp.services.advancedfiltering.net

# General Black/White List
# accept - match, deny - not match
ldap_bwl_acl:
  warn
    set acl_c_bwl_d = ${lookup ldap{LDAP_C/$acl_c_bwl_ldap_q,$acl_c_bwl_ldap_dn?objectClass,afSMTPBWListIsBlack?base}}
    set acl_c_bl_f = false
    set acl_c_wl_f = false
  accept
    condition = ${extract {afSMTPBWListIsBlack}{$acl_c_bwl_d}{true}{false}}
    # Result
    set acl_c_bl_f = true
    #logwrite = DEBUG: bwl: black
  accept
    condition = ${if bool_lax{$acl_c_bwl_d}}
    set acl_c_wl_f = true
    #logwrite = DEBUG: bwl: white
  deny

# Sender Mail Address Black/White List
# accept - match, deny - not match
sma_bwl_acl:
  warn
    set acl_c_bwl_ldap_q = afSMTPBWListSenderMailAddress=${quote_ldap_dn:$sender_address}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = sender mail address
    #logwrite = DEBUG: sma_bwl
  accept
    # no spf check
    condition = $acl_c_bl_f
  accept
    ! condition = $acl_m_spf_f
    condition = $acl_c_wl_f
  deny
    condition = $acl_m_spf_f
    condition = $acl_c_wl_f
    #logwrite = DEBUG: sma_bwl: SPF fail
  deny

# Certificate Black/White List
# accept - match, deny - not match
cert_bwl_acl:
  deny
    ! condition = ${if bool_lax{$tls_peerdn}}
    #logwrite = DEBUG: cert_bwl: no cert
  warn
    set acl_c_bwl_ldap_q = afSMTPBWListCertificateSubject=${quote_ldap_dn:$tls_peerdn}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = certificate
    #logwrite = DEBUG: cert_bwl ($tls_peerdn)
  accept
    # no certificate verification
    condition = $acl_c_bl_f
  accept
    verify = certificate
    condition = $acl_c_wl_f
  deny
    ! verify = certificate
    condition = $acl_c_wl_f
    #logwrite = DEBUG: cert_bwl: cert verify fail
  deny

# Sender Host Address Black/White List
# accept - match, deny - not match
sha_bwl_acl:
  accept
    set acl_c_bwl_ldap_q = afSMTPBWListHostAddress=${quote_ldap_dn:$sender_host_address}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = sender host address
    #logwrite = DEBUG: sha_bwl
  deny

# Sender Host Name Black/White List
# accept - match, deny - not match
shn_bwl_acl:
  deny
    ! condition = ${if bool_lax{$sender_host_name}}
    #logwrite = DEBUG: shn_bwl: sender host name unknown
  accept
    set acl_c_bwl_ldap_q = afSMTPBWListHostName=${quote_ldap_dn:$sender_host_name}
    acl = ldap_bwl_acl
    set acl_c_bwl_m = sender host name
    #logwrite = DEBUG: shn_bwl
  deny

# Domain Name System Block List
# accept - match, deny - not match
dnsbl_acl:
  deny
    condition = S_TP_F
    set acl_c_bl_f = false
    set acl_c_wl_f = false
    #logwrite = DEBUG: dnsbl: trusted port
  accept
    dnslists = <, ${lookup ldap{LDAP_C/$acl_c_bwl_ldap_dn?afSSMTPDNSBLDomainName?base}}
    set acl_c_bwl_m = DNSBL: $sender_host_address is listed at $dnslist_domain ($dnslist_value: $dnslist_text)
    set acl_c_bl_f = true
    #logwrite = DEBUG: dnsbl
  deny

# Black/White List
# accept - match, deny - not match
bwl_acl:
  accept
    acl = sma_bwl_acl
  accept
    acl = cert_bwl_acl
  accept
    acl = sha_bwl_acl
  accept
    acl = shn_bwl_acl
  accept
    acl = dnsbl_acl
  deny

mail_acl:
  warn
    # SPF Flag
    set acl_m_spf_f = false
    spf = fail
    set acl_m_spf_f = true
    # SPF Msg
    set acl_m_spf_m = $sender_host_address is not allowed to send mail from $sender_address_domain
    #logwrite = DEBUG: spf fail
  warn
    set acl_c_s_wl_f = false
    set acl_c_s_bl_f = false
    set acl_c_bwl_ldap_dn = S_SMTP_LDAP_DN
    acl = bwl_acl
    set acl_c_s_wl_f = $acl_c_wl_f
    set acl_c_s_bl_f = $acl_c_bl_f
    set acl_c_s_bwl_m = system policy: $acl_c_bwl_m
  accept

# User SMTP Realm DN
U_SMTP_R_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+U_SMTP_LDAP_DN
# User SMTP Realm Client DN
U_SMTP_R_C_LDAP_DN = afUClientName=${quote_ldap_dn:$acl_m_u_client},U_SMTP_R_LDAP_DN
# User SMTP Realm Client Domain DN
U_SMTP_R_C_D_LDAP_DN = afUSMTPDomainName=${quote_ldap_dn:$acl_m_u_domain},U_SMTP_R_C_LDAP_DN
# User SMTP Realm Client Domain Mail Box DN
U_SMTP_R_C_D_MB_LDAP_DN = afUSMTPDMBLocalPart=${quote_ldap_dn:$local_part},U_SMTP_R_C_D_LDAP_DN

# * определяем имя домена по синониму
domain_rcpt_acl:
  # ** домен => user_domain
  accept
    # User Domain
    set acl_m_u_domain = ${lookup ldap{LDAP_C/afUSMTPDomainName=${quote_ldap_dn:$domain},U_SMTP_R_C_LDAP_DN?afUSMTPDomainName?base}}
    condition = ${if bool_lax{$acl_m_u_domain}}
    #logwrite = DEBUG: acl_m_u_domain=$acl_m_u_domain
  # ** синоним => user_domain
  accept
    set acl_m_u_domain = ${lookup ldap{LDAP_C/U_SMTP_R_C_LDAP_DN?afUSMTPDomainName?sub?(&(objectClass=afUSMTPDomain)(afUSMTPDomainAliasName=${quote_ldap:$domain}))}}
    condition = ${if bool_lax{$acl_m_u_domain}}
    #logwrite = DEBUG: acl_m_u_domain=$acl_m_u_domain (alias)
  # ** не найден в ou=user => 4xx Replicating, please try again later
  defer
    message = Replicating, please try again later

# Lookup recipient configuration option
# accept - found, deny - not found
conf_rcpt_acl:
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_SMTP_R_C_D_MB_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{$acl_m_u_conf_value}{}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_SMTP_R_C_D_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{$acl_m_u_conf_value}{}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_SMTP_R_C_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{$acl_m_u_conf_value}{}}
  deny

# Black/White List for recipient
# accept - match, deny - not match
bwl_rcpt_acl:
  accept
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_MB_LDAP_DN
    acl = bwl_acl
    # Black/White List Recipient Msg
    set acl_m_bwl_rcpt_m = user recipient policy
  accept
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_D_LDAP_DN
    acl = bwl_acl
    set acl_m_bwl_rcpt_m = user domain policy
  accept
    set acl_c_bwl_ldap_dn = U_SMTP_R_C_LDAP_DN
    acl = bwl_acl
    set acl_m_bwl_rcpt_m = user policy
  deny

# User SMTP MailBox Data
U_SMTP_MB_D = ${lookup ldap{LDAP_C/U_SMTP_R_C_D_MB_LDAP_DN?objectClass,afUSMTPDMBIsAbsent?base?(afUSMTPDMBTimeUpdated>=S_MBCT_D)}}

rcpt_acl:
  # * recipients_count > 0 => 4xx Mail box is temporarily unavailable, please try again later
  defer
    condition = ${if bool_lax{$recipients_count}}
    message = Mail box is temporarily unavailable, please try again later

  # * проверка realm для домена
  # ** нет домена => 5xx The domain is not in service, stop
  deny
    # User Client (name/id)
    set acl_m_u_client = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
    #logwrite = DEBUG: acl_m_u_client=$acl_m_u_client
    ! condition = ${if bool_lax{$acl_m_u_client}}
    message = The domain is not in service
  # ** чужой realm => 4xx Moved, try another host, stop
  defer
    # User Realm
    set acl_m_u_realm = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:$acl_m_u_client},S_LDAP_DN?afSClientRealm?base}}
    #logwrite = DEBUG: acl_m_u_realm=$acl_m_u_realm
    ! condition = ${if inlist{$acl_m_u_realm}{<, S_REALM_Lc}}
    message = Moved, try another host
  # * определяем имя домена по синониму
  require
    acl = domain_rcpt_acl

  # * получение пользовательской настройки user_nombxchk (NoMailBoxCheck - no auto-add)
  warn
    set acl_m_u_nombxchk_f = false
    set acl_m_u_conf_name = afUSMTPNoMailBoxCheck
    acl = conf_rcpt_acl
    set acl_m_u_nombxchk_f = $acl_m_u_conf_value

  # * проверка адреса получателя в afMailBox (с учетом MailBox Timeout)
  # ** absent && sys_spamtrap => 2xx SST/MBA Mail box does not exist, flag_mb_absent, stop
  accept
    condition = $acl_c_s_st_f
    condition = ${extract {afUSMTPDMBIsAbsent}{U_SMTP_MB_D}{true}{false}}
    set acl_m_u_absent = true
    message = SST/MBA Mail box does not exist
  # ** absent => 5xx Mail box does not exist, stop
  deny
    condition = ${extract {afUSMTPDMBIsAbsent}{U_SMTP_MB_D}{true}{false}}
    message = Mail box does not exist
  # ** (expired || not_found) && user_nombxchk && sys_spamtrap => 2xx UNMBC,SST/MBA Mail box does not exist, flag_mb_absent, stop
  accept
    condition = $acl_c_s_st_f
    condition = $acl_m_u_nombxchk_f
    # existing
    ! condition = ${extract {objectClass}{U_SMTP_MB_D}{true}{false}}
    set acl_m_u_absent = true
    message = UNMBC,SST/MBA Mail box does not exist
  # ** (expired || not_found) && user_nombxchk => 5xx UNMBC/ Mail box does not exist, stop
  deny
    condition = $acl_m_u_nombxchk_f
    # existing
    ! condition = ${extract {objectClass}{U_SMTP_MB_D}{true}{false}}
    message = UNMBC/ Mail box does not exist
  # ** expired || not_found => 4xx Your data is verifying, please try again later, log, stop
  defer
    # existing
    ! condition = ${extract {objectClass}{U_SMTP_MB_D}{true}{false}}
    message = Your data is verifying, please try again later
    logwrite = AdvancedFiltering:NewMailBox:<$local_part>Domain:<$acl_m_u_domain>Client:<$acl_m_u_client>Realm:<$acl_m_u_realm>
  # ** ok

  # $recipients не доступен в transports
  warn
    set acl_m_recipient = $local_part@$domain

  # * получение пользовательской настройки user_spt (Spam PassThrough)
  warn
    set acl_m_u_spt_f = false
    set acl_m_u_conf_name = afUSMTPSpamPassthrough
    acl = conf_rcpt_acl
    set acl_m_u_spt_f = $acl_m_u_conf_value

  # * проверка пользовательских списков фильтрации => flag_user_wl, flag_user_bl, msg_user_wbl
  warn
    set acl_m_u_wl_f = false
    set acl_m_u_bl_f = false
    acl = bwl_rcpt_acl
    set acl_m_u_wl_f = $acl_c_wl_f
    set acl_m_u_bl_f = $acl_c_bl_f
    set acl_m_u_bwl_m = $acl_m_bwl_rcpt_m: $acl_c_bwl_m

  # * flag_user_wl => 2xx UWL/ ($msg_user_wbl), stop
  accept
    condition = $acl_m_u_wl_f
    message = UWL/ ($acl_m_u_bwl_m)

  # * flag_user_bl => 5xx UBL/ ($msg_user_wbl), stop
  deny
    condition = $acl_m_u_bl_f
    message = UBL/ ($acl_m_u_bwl_m)

  # * flag_sys_wl => 2xx SWL/ ($msg_sys_wbl), stop
  accept
    condition = $acl_c_s_wl_f
    message = SWL/ ($acl_c_s_bwl_m)

  # * flag_sys_bl && !sys_spamtrap && !user_spt => 5xx SBL/ ($msg_sys_wbl), stop
  deny
    condition = $acl_c_s_bl_f
    ! condition = $acl_c_s_st_f
    ! condition = $acl_m_u_spt_f
    message = SBL/ ($acl_c_s_bwl_m)

  # * flag_sys_bl => 2xx SBL,(SST|USPT)/ ($msg_sys_wbl), stop
  accept
    condition = $acl_c_s_bl_f
    message = SBL,(SST|USPT)/ ($acl_c_s_bwl_m)

  # * flag_spf && !user_spt && !sys_spamtrap => 5xx SPF/ (SPF: ...), stop
  deny
    condition = $acl_m_spf_f
    ! condition = $acl_m_u_spt_f
    ! condition = $acl_c_s_st_f
    message = SPF/ (SPF: $acl_m_spf_m)

  # * flag_spf => 2xx SPF,(USPT|SST)/ (SPF: ...), stop
  accept
    condition = $acl_m_spf_f
    message = SPF,(USPT|SST)/ (SPF: $acl_m_spf_m)

  # * ok
  accept

dkim_acl:
  # * dkim_domain != dkim.advancedfiltering.net => ok
  accept
    condition = ${if ! eqi{$dkim_domain}{dkim.advancedfiltering.net}}
    #logwrite = DEBUG: DKIM: skip domain: $dkim_domain
  # * dkim_verify_status != pass => ok
  accept
    condition = ${if ! eq{$dkim_verify_status}{pass}}
    #logwrite = DEBUG: DKIM: skip bad sig: $dkim_verify_status ($dkim_verify_reason)
  # * проверка Via-Recipients (message_loop_detector.pl) => 5xx Message loop detected (stdout)
  deny
    # optimization
    condition = ${if bool_lax{$header_X-AdvancedFiltering-Via-Recipients:}}
    condition = ${run{/usr/local/advancedfiltering/smtp/exim/message_loop_detector.pl $header_X-AdvancedFiltering-Via-Recipients: $acl_m_recipient}{true}{false}}
    message = Message loop detected ($value)
  # * ok
  accept

# Message Incoming Header
U_MI_H_D = $bheader_Message-ID:
# Message Incoming Data
U_MI_D = ${run{/usr/local/advancedfiltering/smtp/exim/mid_list_encoder.pl U_MI_H_D}{$value}{}}

# User SMTP DataBase LDAP DN
U_SMTPDB_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+afUServiceName=smtpdb,ou=user,o=advancedfiltering

# User SMTP DB Message Incoming
U_SMTPDB_MI_spam_D = ${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:U_MI_D},U_SMTPDB_LDAP_DN?afUSMTPMessageSpamDescription?base}}
U_SMTPDB_MI_sender_D = ${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:U_MI_D},U_SMTPDB_LDAP_DN?afUSMTPMessageSenderMailAddress?base}}

# Message Outgoing Header(s)
U_MO_H_D = $bheader_In-Reply-To: $bheader_References:
# Message Outgoing List
U_MO_L = ${run{/usr/local/advancedfiltering/smtp/exim/mid_list_encoder.pl U_MO_H_D}{$value}{}}

# User Submission DataBase LDAP DN
U_SDB_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+afUServiceName=sdb,ou=user,o=advancedfiltering

# User SDB Message Outgoing
U_SDB_MO_sender_L = ${map{U_MO_L}{${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:$item},U_SDB_LDAP_DN?afUSMTPMessageSenderMailAddress?base}}}}

data_acl:
  # * flag_mb_absent => fake/5xx MBA/ST Mail box does not exist. id=..., stop, flag_spamtrap
  accept
    condition = ${if bool_lax{$acl_m_u_absent}}
    set acl_m_spamtrap_f = true
    control = fakereject/MBA/ST Mail box does not exist. id=$message_exim_id

  # * flag_user_wl => 2xx UWL/ ($msg_user_wbl) id=..., stop
  accept
    condition = $acl_m_u_wl_f
    message = UWL/ ($acl_m_u_bwl_m) id=$message_exim_id

  # * flag_sys_wl => 2xx SWL/ ($msg_sys_wbl) id=..., stop
  accept
    condition = $acl_c_s_wl_f
    message = SWL/ ($acl_c_s_bwl_m) id=$message_exim_id

  # * flag_sys_bl && user_spt => 2xx SBL,USPT/ST,S ($msg_sys_wbl) id=..., stop, flag_spamtrap, flag_spam
  accept
    condition = $acl_c_s_bl_f
    condition = $acl_m_u_spt_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = SBL,USPT/ST,S ($acl_c_s_bwl_m) id=$message_exim_id

  # * flag_sys_bl => fake/5xx SBL/ST,S ($msg_sys_wbl) id=..., stop, flag_spamtrap, flag_spam
  accept
    condition = $acl_c_s_bl_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    control = fakereject/SBL/ST,S ($acl_c_s_bwl_m) id=$message_exim_id

  # * flag_spf && user_spt => 2xx SPF,USPT/ST,S (SPF: ...) id=..., stop, flag_spamtrap, flag_spam
  accept
    condition = $acl_m_spf_f
    condition = $acl_m_u_spt_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = SPF,USPT/ST,S (SPF: $acl_m_spf_m) id=$message_exim_id

  # * flag_spf => fake/5xx SPF/ST,S (SPF: ...) id=..., stop, log Message-ID, flag_spamtrap, flag_spam
  accept
    condition = $acl_m_spf_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    control = fakereject/SPF/ST,S (SPF: $acl_m_spf_m) id=$message_exim_id

  # * проверка Message-Id в afMessageIncoming
  # ** нет MessageId && user_spt => 2xx USPT/S (No Message-ID header) id=..., stop, flag_spam
  accept
    ! condition = ${if bool_lax{U_MI_H_D}}
    condition = $acl_m_u_spt_f
    set acl_m_spam_f = true
    message = USPT/S (No Message-ID header) id=$message_exim_id
  # ** нет MessageId => 5xx Malformed (No Message-ID header) id=..., stop
  deny
    ! condition = ${if bool_lax{U_MI_H_D}}
    message = Malformed (No Message-ID header) id=$message_exim_id
  # ** ok, afIsSpam && user_spt => 2xx USPT/S ($afSpamDescription) id=..., stop, flag_spam
  accept
    condition = ${if bool_lax{U_SMTPDB_MI_spam_D}}
    condition = $acl_m_u_spt_f
    set acl_m_spam_f = true
    message = USPT/S (U_SMTPDB_MI_spam_D) id=$message_exim_id
  # ** ok, afIsSpam => 5xx Spam ($afSpamDescription) id=..., stop
  deny
    condition = ${if bool_lax{U_SMTPDB_MI_spam_D}}
    message = Spam (U_SMTPDB_MI_spam_D) id=$message_exim_id
  # ** не совпадает sender && user_spt => 2xx USPT/ST,S (Several senders for the same message) id=..., stop, flag_spamtrap, flag_spam
  accept
    condition = ${if bool_lax{U_SMTPDB_MI_sender_D}}
    condition = ${if ! eqi{U_SMTPDB_MI_sender_D}{$sender_address}}
    condition = $acl_m_u_spt_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = USPT/ST,S (Several senders for the same message) id=$message_exim_id
  # ** не совпадает sender && sys_spamtrap => fake/5xx SST/ST,S (Several senders for the same message) id=..., stop, flag_spamtrap, flag_spam
  accept
    condition = ${if bool_lax{U_SMTPDB_MI_sender_D}}
    condition = ${if ! eqi{U_SMTPDB_MI_sender_D}{$sender_address}}
    condition = $acl_c_s_st_f
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    control = fakereject/SST/ST,S (Several senders for the same message) id=$message_exim_id
  # ** не совпадает sender => 5xx Bad sender (Several senders for the same message) id=..., stop
  deny
    condition = ${if bool_lax{U_SMTPDB_MI_sender_D}}
    condition = ${if ! eqi{U_SMTPDB_MI_sender_D}{$sender_address}}
    set acl_m_spamtrap_f = true
    set acl_m_spam_f = true
    message = Bad sender (Several senders for the same message) id=$message_exim_id
  # ** ok => ok, stop
  accept
    condition = ${if bool_lax{U_SMTPDB_MI_sender_D}}

  # * проверка In-Reply-To, References в afMessageOutgoing
  # ** ok => 2xx /HT id=..., stop, flag_hamtrap
  accept
    condition = ${if bool_lax{U_MO_H_D}}
    #logwrite = DEBUG: realm: $acl_m_u_realm
    #logwrite = DEBUG: references: U_MO_L
    #logwrite = DEBUG: senders: U_SDB_MO_sender_L
    #logwrite = DEBUG: recipient: $acl_m_recipient
    condition = ${if forany{U_SDB_MO_sender_L}{eqi{$item}{$acl_m_recipient}}}
    set acl_m_hamtrap_f = true
    message = /HT id=$message_exim_id

  # * message_size >= sys_trustedmessagesize
  # ** ok => 2xx TMS/ id=..., stop
  accept
    condition = ${if >{$message_size}{S_TMS_D}}
    message = TMS/ id=$message_exim_id

  # * 4xx /MP Your data is verifying, please try again later. id=..., flag_mailproc
  accept
    set acl_m_mailproc_f = true
    control = fakedefer//MP Your data is verifying, please try again later. id=$message_exim_id

begin routers

# Router Client
R_CLIENT = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
# Router Client Realm
R_C_REALM = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:R_CLIENT},S_LDAP_DN?afSClientRealm?base}}

# (is needed for service_* routers and submission_* routers)
# Router Address_Data Realm LDAP Query (needed for service_* routers and submission_* routers)
R_AD_R_LDAP_Q = afSHostRealm=${quote_ldap_dn:${extract {realm} {$address_data} }}
# Router Address_Data Realm Flag
R_AD_R_F = ${extract {realm} {$address_data} }
# Router System Realm LDAP Query
R_SYS_R_LDAP_Q = ${reduce {S_REALM_Lc} {|} {$value(afSHostRealm=${quote_ldap_dn:$item})} }
# Router Services Realm LDAP Q
R_S_R_LDAP_Q = ${if bool_lax{R_AD_R_F} {R_AD_R_LDAP_Q} {R_SYS_R_LDAP_Q} }

# errors_to addresses need to be verified
service_verify_router:
  verify_only = true
  domains = services.advancedfiltering.net
  driver = accept

# Routers/Service Router Route Data Hosts List (separated by \n)
R_SRRD_H_Lnl = ${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_S_R_LDAP_Q)(afSHostServiceName=$local_part))}}
# Routers/Service Router Route Data Address (uses $item)
R_SRRD_address_I = ${lookup ldap{LDAP_C/afSHostServiceName=$local_part,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceHostAddress?base}}
# Routers/Service Router Route Data Port (uses $item)
R_SRRD_port_I = ${lookup ldap{LDAP_C/afSHostServiceName=$local_part,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceTCPPort?base}}
# Routers/Service Router Route Data List (separated by \n)
R_SRRD_Lnl = ${map{<\n R_SRRD_H_Lnl}{${if bool_lax{R_SRRD_address_I}{R_SRRD_address_I}{$item}}${if bool_lax{R_SRRD_port_I}{:R_SRRD_port_I}{}}}}

# * service [@services] {stop} => error
service_router:
  # prevent address_data update
  condition = ${if bool_lax{R_SRRD_Lnl}}
  domains = services.advancedfiltering.net
  driver = manualroute
  #debug_print = address_data = $address_data, sys_r = R_SYS_R_LDAP_Q
  route_data = \"<\n R_SRRD_Lnl\"
  hosts_randomize = true
  transport = service_transport
  address_data = system_authenticator="true" $address_data
  # error delivery loop prevention
  errors_to = ${if eqi{$local_part}{error}{}{error@services.advancedfiltering.net}}
  self = send

# * service_defer [@services] {stop} -> service => error
service_defer_router:
  domains = services.advancedfiltering.net
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router

# * mailproc [flag_mailproc] {stop} (-> service) => error
mailproc_router:
  condition = $acl_m_mailproc_f
  driver = redirect
  data = mailproc@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router

# * hamtrap [flag_hamtrap && sys_hamtrap] {continue} (-> service) => error
hamtrap_router:
  condition = $acl_c_s_ht_f
  condition = $acl_m_hamtrap_f
  driver = redirect
  data = hamtrap@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router
  unseen = true

# * spamtrap [flag_spamtrap && sys_spamtrap] {continue} (-> service) => error
spamtrap_router:
  condition = $acl_c_s_st_f
  condition = $acl_m_spamtrap_f
  driver = redirect
  data = spamtrap@services.advancedfiltering.net
  address_data = realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router
  unseen = true

# * absent :blackhole: [flag_mb_absent] {stop} => error
absent_router:
  condition = $acl_m_u_absent
  driver = redirect
  data = :blackhole:
  errors_to = error@services.advancedfiltering.net

# * spam :blackhole: [flag_spam && !user_spt] {stop} => error
spam_router:
  condition = $acl_m_spam_f
  condition = ${if ! bool_lax{$acl_m_u_spt_f}}
  driver = redirect
  data = :blackhole:
  errors_to = error@services.advancedfiltering.net

# Router Client LDAP DN
R_C_LDAP_DN = afUClientName=${quote_ldap_dn:R_CLIENT},afUServiceRealm=${quote_ldap_dn:R_C_REALM}+U_SMTP_LDAP_DN
# Router Client Domain LDAP DN
R_CD_LDAP_DN = afUSMTPDomainName=${quote_ldap_dn:$domain},R_C_LDAP_DN
# Router Client Domain Mail Box LDAP DN
R_CDM_LDAP_DN = afUSMTPDMBLocalPart=${quote_ldap_dn:$local_part},R_CD_LDAP_DN
# Router MailBox Absent Data
R_MBA_D = ${lookup ldap{LDAP_C/R_CDM_LDAP_DN?afUSMTPDMBIsAbsent?base}}

# *************************************************************************************************

# same contents for all copy routers (spamaddress_*, backup_*, redirect_*, spambox_*)
# (except condition clause)

# *************************************************************************************************

# Router General LDAP DN
R_LDAP_DN = ""

# Router Copy Target Data
R_CT_D = ""

# Router Copy Target List (separated by coma)
R_CT_Lc = ""

# Router Copy Sender Data
R_CS_D = ""

# * spamaddress_rcpt [flag_spam] {stop} -> submission => error
R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all spamaddress_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailAddress?base}}
spamaddress_rcpt_router:
  condition = $acl_m_spam_f
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router

# * spamaddress_domain [flag_spam] {stop} -> submission => error
R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base}}
# the same for all spamaddress_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailAddress?base}}
spamaddress_domain_router:
  condition = $acl_m_spam_f
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router

# * spamaddress_client [flag_spam] {stop} -> submission => error
R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base}}
# the same for all spamaddress_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailAddress?base}}
spamaddress_client_router:
  condition = $acl_m_spam_f
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router

# * backup_rcpt [!flag_spam] {continue} -> submission >> redirect => error
R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPBackupMailAddress?base}}
backup_rcpt_router:
  condition = ${if ! bool_lax{$acl_m_spam_f}}
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router
  unseen = true
backup_rcpt_pass_router:
  condition = ${if ! bool_lax{$acl_m_spam_f}}
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = $local_part@$domain
  errors_to = error@services.advancedfiltering.net
  redirect_router = redirect_router

# * backup_domain [!flag_spam] {continue} -> submission >> redirect => error
R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base}}
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPBackupMailAddress?base}}
backup_domain_router:
  condition = ${if ! bool_lax{$acl_m_spam_f}}
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router
  unseen = true
backup_domain_pass_router:
  condition = ${if ! bool_lax{$acl_m_spam_f}}
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = $local_part@$domain
  errors_to = error@services.advancedfiltering.net
  redirect_router = redirect_router

# * backup_client [!flag_spam] {continue} -> submission >> redirect => error
R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base}}
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPBackupMailAddress?base}}
backup_client_router:
  condition = ${if ! bool_lax{$acl_m_spam_f}}
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router
  unseen = true
backup_client_pass_router:
  condition = ${if ! bool_lax{$acl_m_spam_f}}
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = $local_part@$domain
  errors_to = error@services.advancedfiltering.net
  redirect_router = redirect_router

# * redirect
redirect_router:
  driver = redirect
  data = ""

# * redirect_rcpt {stop} -> submission => error
R_LDAP_DN == R_CDM_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all redirect_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPRedirectMailAddress?base}}
redirect_rcpt_router:
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router

# * redirect_domain {stop} -> submission => error
R_LDAP_DN == R_CD_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPDomainTechMailAddress?base}}
# the same for all redirect_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPRedirectMailAddress?base}}
redirect_domain_router:
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router

# * redirect_client {stop} -> submission => error
R_LDAP_DN == R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base}}
# the same for all redirect_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPRedirectMailAddress?base}}
redirect_client_router:
  # prevent address_data update
  condition = ${if bool_lax{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router

# * spambox_rcpt [flag_spam] {stop} -> mx => error
R_LDAP_DN == R_CDM_LDAP_DN
# the same for all spambox_ routers
R_CT_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailBox?base}}
spambox_rcpt_router:
  condition = $acl_m_spam_f
  # prevent address_data update
  condition = ${if bool_lax{R_CT_D}}
  driver = redirect
  data = R_CT_D+$local_part@$domain
  address_data = sender=$sender_address realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = mx_router

# * spambox_domain [flag_spam] {stop} -> mx => error
R_LDAP_DN == R_CD_LDAP_DN
# the same for all spambox_ routers
R_CT_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailBox?base}}
spambox_domain_router:
  condition = $acl_m_spam_f
  # prevent address_data update
  condition = ${if bool_lax{R_CT_D}}
  driver = redirect
  data = R_CT_D+$local_part@$domain
  address_data = sender=$sender_address realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = mx_router

# * spambox_client [flag_spam] {stop} -> mx => error
R_LDAP_DN == R_C_LDAP_DN
# the same for all spambox_ routers
R_CT_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPSpamMailBox?base}}
spambox_client_router:
  condition = $acl_m_spam_f
  # prevent address_data update
  condition = ${if bool_lax{R_CT_D}}
  driver = redirect
  data = R_CT_D+$local_part@$domain
  address_data = sender=$sender_address realm=R_C_REALM $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = mx_router

# Routers/Mail Exchanger Name List (separated by coma)
R_MX_N_Lc = ""
# Routers/Mail Exchanger Address (uses $item)
R_MX_address_I = ""
# Routers/Mail Exchanger Port (uses $item)
R_MX_port_I = ""
# Routers/Mail Exchanger Address:Port (uses $item)
R_MX_address_port_I = ""
# Routers/Mail Exchanger Address/Port (uses $item) - for authenticators
R_MX_address__port_I = ""
# Routers/Mail Exchanger User (uses $item)
R_MX_user_I = ""
# Routers/Mail Exchanger Password (uses $item)
R_MX_password_I = ""
# Routers/Mail Exchanger List (separated by coma)
R_MX_Lc = ""

# * mx
mx_router:
  driver = redirect
  data = ""

# * mx_rcpt {stop} => bounce
R_LDAP_DN == R_CDM_LDAP_DN
R_MX_N_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPMXName?base}}
R_MX_address_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXHostName?base}}
R_MX_port_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXTCPPort?base}}
R_MX_user_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthUser?base}}
R_MX_password_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthPassword?base}}
R_MX_address_port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I${if bool_lax{R_MX_port_I}{:R_MX_port_I}{}}}{}}
R_MX_address__port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I${if bool_lax{R_MX_port_I}{/R_MX_port_I}{}}}{}}
R_MX_Lc == ${map{<, R_MX_N_Lc}{R_MX_address_port_I}}
mx_rcpt_router:
  # prevent address_data update
  condition = ${if bool_lax{R_MX_Lc}}
  driver = manualroute
  route_data = \"<, R_MX_Lc\"
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<, R_MX_N_Lc} {} {$value R_MX_address__port_I/user=R_MX_user_I R_MX_address__port_I/password=R_MX_password_I R_MX_address__port_I/name=$item}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport
  self = send

# * mx_domain {stop} => bounce
R_LDAP_DN == R_CD_LDAP_DN
R_MX_N_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPMXName?base}}
R_MX_address_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXHostName?base}}
R_MX_port_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXTCPPort?base}}
R_MX_user_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthUser?base}}
R_MX_password_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthPassword?base}}
R_MX_address_port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I${if bool_lax{R_MX_port_I}{:R_MX_port_I}{}}}{}}
R_MX_address__port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I${if bool_lax{R_MX_port_I}{/R_MX_port_I}{}}}{}}
R_MX_Lc == ${map{<, R_MX_N_Lc}{R_MX_address_port_I}}
mx_domain_router:
  # prevent address_data update
  condition = ${if bool_lax{R_MX_Lc}}
  driver = manualroute
  route_data = \"<, R_MX_Lc\"
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<, R_MX_N_Lc} {} {$value R_MX_address__port_I/user=R_MX_user_I R_MX_address__port_I/password=R_MX_password_I R_MX_address__port_I/name=$item}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport
  self = send

# * mx_client {stop} => bounce
R_LDAP_DN == R_C_LDAP_DN
R_MX_N_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSMTPMXName?base}}
R_MX_address_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXHostName?base}}
R_MX_port_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXTCPPort?base}}
R_MX_user_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthUser?base}}
R_MX_password_I == ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:$item},R_LDAP_DN?afUSMTPMXAuthPassword?base}}
R_MX_address_port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I${if bool_lax{R_MX_port_I}{:R_MX_port_I}{}}}{}}
R_MX_address__port_I == ${if bool_lax{R_MX_address_I}{R_MX_address_I${if bool_lax{R_MX_port_I}{/R_MX_port_I}{}}}{}}
R_MX_Lc == ${map{<, R_MX_N_Lc}{R_MX_address_port_I}}
mx_client_router:
  # prevent address_data update
  condition = ${if bool_lax{R_MX_Lc}}
  driver = manualroute
  route_data = \"<, R_MX_Lc\"
  address_data = mx_ldap_dn=R_LDAP_DN ${reduce {<, R_MX_N_Lc} {} {$value R_MX_address__port_I/user=R_MX_user_I R_MX_address__port_I/password=R_MX_password_I R_MX_address__port_I/name=$item}} $address_data
  errors_to = bounce@services.advancedfiltering.net
  transport = mx_transport
  self = send

# * mx_defer {stop} -> mx => bounce
mx_defer_router:
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = bounce@services.advancedfiltering.net
  redirect_router = mx_router

# (client copy mail, delivery to other addresses)
# the realm should be in the address_data, if not - the leaked bounce (errors_to verification failed)

# Routers/Submission Router Route Data Hosts List
R_SubRRD_H_Lnl = ${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_AD_R_LDAP_Q)(afSHostServiceName=submission))}}
# Routers/Submission Router Route Data Address (uses $item)
R_SubRRD_address_I = ${lookup ldap{LDAP_C/afSHostServiceName=submission,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceHostAddress?base}}
# Routers/Submission Router Route Data Port (uses $item)
R_SubRRD_port_I = ${lookup ldap{LDAP_C/afSHostServiceName=submission,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceTCPPort?base}}
# Routers/Submission Router Route Data List
R_SubRRD_Lnl = ${map{<\n R_SubRRD_H_Lnl}{${if bool_lax{R_SubRRD_address_I}{R_SubRRD_address_I}{$item}}${if bool_lax{R_SubRRD_port_I}{:R_SubRRD_port_I}{}}}}

# * submission {stop} => error
submission_router:
  # prevent address_data update
  condition = ${if bool_lax{R_SubRRD_Lnl}}
  driver = manualroute
  route_data = \"<\n R_SubRRD_Lnl\"
  hosts_randomize = true
  transport = submission_transport
  address_data = system_authenticator="true" $address_data
  # loosing a copy mail, bad but is the best solution
  errors_to = error@services.advancedfiltering.net
  self = send

# * submission_defer {stop} -> submission => error
submission_defer_router:
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net
  redirect_router = submission_router

begin transports

service_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/advancedfiltering_ssl/$primary_hostname.crt
  tls_privatekey = /etc/advancedfiltering_ssl/$primary_hostname.key
  tls_verify_certificates = /etc/advancedfiltering_ssl/ca
  tls_crl = /etc/advancedfiltering_ssl/ca
  # no return path fix

submission_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/advancedfiltering_ssl/$primary_hostname.crt
  tls_privatekey = /etc/advancedfiltering_ssl/$primary_hostname.key
  tls_verify_certificates = /etc/advancedfiltering_ssl/ca
  tls_crl = /etc/advancedfiltering_ssl/ca
  # return path fix (address_data)
  return_path = ${extract {sender} {$address_data} }
  dkim_domain = dkim.advancedfiltering.net
  dkim_selector = smtp
  dkim_private_key = /usr/local/advancedfiltering/smtp/dkim-smtp.key
  dkim_canon = relaxed
  dkim_strict = true
#   RFC4871
#   The following header fields SHOULD be included in the signature, if
#   they are present in the message being signed:
#   o  From (REQUIRED in all signatures)
#   o  Sender, Reply-To
#   o  Subject
#   o  Date, Message-ID
#   o  To, Cc
#   o  MIME-Version
#   o  Content-Type, Content-Transfer-Encoding, Content-ID, Content-Description
#   o  Resent-Date, Resent-From, Resent-Sender, Resent-To, Resent-Cc, Resent-Message-ID
#   o  In-Reply-To, References
#   o  List-Id, List-Help, List-Unsubscribe, List-Subscribe, List-Post, List-Owner, List-Archive
#   The following header fields SHOULD NOT be included in the signature:
#   o  Return-Path
#   o  Received
#   o  Comments, Keywords
#   o  Bcc, Resent-Bcc
#   o  DKIM-Signature
  dkim_sign_headers = \
From:Sender:Reply-To:Subject:Date:Message-ID:To:Cc:MIME-Version:\
Content-Type:Content-Transfer-Encoding:Content-ID:Content-Description:\
Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:\
In-Reply-To:References:\
List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive:\
X-AdvancedFiltering-Via-Recipients
  headers_remove = X-AdvancedFiltering-Via-Recipients
  headers_add = X-AdvancedFiltering-Via-Recipients:$header_X-AdvancedFiltering-Via-Recipients: $acl_m_recipient

# Transport LDAP DN
T_LDAP_DN = ${extract {mx_ldap_dn} {$address_data} }
# Transport Mail eXchanger Name Data
# not using ":" in keys - not allowed in authenticators
T_MXN_D = ${extract {$host${if bool_lax{$smtp_host_specific_port}{/$smtp_host_specific_port}{}}/name} {$address_data} }
# Transport Auth-required Hosts
T_AH_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXHostName?base?(afUSMTPMXAuthUser=*)} }
# Transport TLS-required Hosts
T_TH_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXHostName?base?(afUSMTPMXTLSRequired=TRUE)} }
# Transport TLS Certificate
T_TLSC_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXAuthTLSCertificate?base}}
# Transport TLS Key
T_TLSK_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXAuthTLSKey?base}}
# Transport TLS Verify data, OpenSSL path to root certificates & crls
T_TLSV_D = ${lookup ldap{LDAP_C/afUSMTPMXName=${quote_ldap_dn:T_MXN_D},T_LDAP_DN?afUSMTPMXAuthTLSCA?base}}

mx_transport:
  driver = smtp
  # mandatory auth & tls
  hosts_require_auth = T_AH_D
  hosts_require_tls = T_TH_D
  # public cert, no verify
  tls_certificate = ${if bool_lax{T_TLSC_D} {/usr/local/advancedfiltering/smtp/ssl/T_TLSC_D.crt} {/usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.crt} }
  tls_privatekey = ${if bool_lax{T_TLSK_D} {/usr/local/advancedfiltering/smtp/ssl/T_TLSK_D.key} {/usr/local/advancedfiltering/ssl/smtp.services.advancedfiltering.net.key} }
  tls_verify_certificates = ${if bool_lax{T_TLSV_D} {/usr/local/advancedfiltering/smtp/ssl/T_TLSV_D} fail }
  # return path fix (sender_address)
  return_path = $sender_address
  dkim_domain = dkim.advancedfiltering.net
  dkim_selector = smtp
  dkim_private_key = /usr/local/advancedfiltering/smtp/dkim-smtp.key
  dkim_canon = relaxed
  dkim_strict = true
#   RFC4871
#   The following header fields SHOULD be included in the signature, if
#   they are present in the message being signed:
#   o  From (REQUIRED in all signatures)
#   o  Sender, Reply-To
#   o  Subject
#   o  Date, Message-ID
#   o  To, Cc
#   o  MIME-Version
#   o  Content-Type, Content-Transfer-Encoding, Content-ID, Content-Description
#   o  Resent-Date, Resent-From, Resent-Sender, Resent-To, Resent-Cc, Resent-Message-ID
#   o  In-Reply-To, References
#   o  List-Id, List-Help, List-Unsubscribe, List-Subscribe, List-Post, List-Owner, List-Archive
#   The following header fields SHOULD NOT be included in the signature:
#   o  Return-Path
#   o  Received
#   o  Comments, Keywords
#   o  Bcc, Resent-Bcc
#   o  DKIM-Signature
  dkim_sign_headers = \
From:Sender:Reply-To:Subject:Date:Message-ID:To:Cc:MIME-Version:\
Content-Type:Content-Transfer-Encoding:Content-ID:Content-Description:\
Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:\
In-Reply-To:References:\
List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive:\
X-AdvancedFiltering-Via-Recipients
  headers_remove = X-AdvancedFiltering-Via-Recipients
  headers_add = X-AdvancedFiltering-Via-Recipients:$header_X-AdvancedFiltering-Via-Recipients: $acl_m_recipient

begin retry

# DEBUG
^\N[^@]+@test\-smtp\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@w01\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@w02\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@h01\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@h02\.hosts\.advancedfiltering\.net$\N * F,5s,1s

services.advancedfiltering.net * F,15m,1m; H,7d,15m,2
bounce@services.advancedfiltering.net * F,15m,1m; F,1d,15m

* rcpt_4xx F,1m,5s; F,15m,1m; F,1h,15m; F,1d,1h
* * F,15m,1m; F,1h,15m; F,1d,1h

begin authenticators

# client_send does not allow ":" in the data
A_USER = ${extract {$host${if bool_lax{$smtp_host_specific_port}{/$smtp_host_specific_port}{}}/user} {$address_data} }
A_PASSWORD = ${extract {$host${if bool_lax{$smtp_host_specific_port}{/$smtp_host_specific_port}{}}/password} {$address_data} }

user_cram_md5_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = cram_md5
  public_name = CRAM-MD5
  client_name = A_USER
  client_secret = A_PASSWORD

user_login_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = plaintext
  public_name = LOGIN
  client_send = :A_USER:A_PASSWORD

user_plain_authenticator:
  client_condition = ${if bool_lax{A_USER}}
  driver = plaintext
  public_name = PLAIN
  client_send = ^A_USER^A_PASSWORD
