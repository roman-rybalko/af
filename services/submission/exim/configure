exim_user = advancedfiltering_submission
exim_group = advancedfiltering_submission
log_file_path = /usr/local/advancedfiltering/submission/exim/log/%s.log
process_log_path = /usr/local/advancedfiltering/submission/exim/exim-process.info
spool_directory = /usr/local/advancedfiltering/submission/exim/spool
split_spool_directory = true
never_users = root
daemon_smtp_ports = 587
# требуется для sys_trustedhost
host_lookup = *
rfc1413_hosts = :
rfc1413_query_timeout = 0s
smtp_receive_timeout = 42s
local_scan_timeout = 15s
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d
acl_smtp_connect = connect_acl
acl_smtp_mail = mail_acl
acl_smtp_rcpt = rcpt_acl
acl_smtp_data = data_acl

# Lightweight Directory Access Protocol Connection
LDAP_C = ldapi://%2fusr%2flocal%2fadvancedfiltering%2fldap%2fldapi
# System LDAP DN
S_LDAP_DN = ou=system,o=advancedfiltering
# System Submission LDAP DN
S_Submission_LDAP_DN = afSServiceName=submission,S_LDAP_DN
# User Submission LDAP DN
U_Submission_LDAP_DN = afUServiceName=submission,ou=user,o=advancedfiltering
# System Realm List (separated by coma)
S_REALM_Lc = ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$primary_hostname},S_LDAP_DN?afSHostRealm?base}}

# System Trusted Host Flag
S_TH_F = ${if eq{$sender_host_name}{}{false}{${if forany{<, ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$sender_host_name},S_LDAP_DN?afSHostRealm?base}}}{inlist{$item}{<, S_REALM_Lc}}{true}{false}}}}

# System Host Certificate
S_H_C_D = /etc/advancedfiltering_ssl/$primary_hostname.crt
# System Host Certificate Key
S_H_CK_D = /etc/advancedfiltering_ssl/$primary_hostname.key
# System Host Certificate Authority
S_H_CA_D = /etc/advancedfiltering_ssl/ca

# User Client Name by IP
U_CN_ip_D = ${lookup ldap{LDAP_C/afSSubmissionAuthHostAddress=${quote_ldap_dn:$sender_host_address},S_Submission_LDAP_DN?afSSubmissionAuthClientName?base}}
# User Client Name by TLS SNI (DNS name: submission.xxx.clients.advancedfiltering.net, submission2.xxx.clients.advancedfiltering.net)
U_CN_sni_D = ${sg{${sg{$tls_in_sni}{submission\\d*\\.}{}}}{\\.clients.advancedfiltering.net}{}}
# User Client Name by SMTP AUTH
U_CN_login_D = $authenticated_id

# User Client Name
U_CN_D = ${if eq{U_CN_ip_D}{}{${if eq{U_CN_sni_D}{}{${if eq{U_CN_login_D}{}{}{U_CN_login_D}}}{U_CN_sni_D}}}{U_CN_ip_D}}

# User Client Certificate
U_C_C_D = ${if exists{/usr/local/advancedfiltering/submission/ssl/U_CN_D.crt}{/usr/local/advancedfiltering/submission/ssl/U_CN_D.crt}{}}
U_C_CK_D = ${if exists{/usr/local/advancedfiltering/submission/ssl/U_CN_D.key}{/usr/local/advancedfiltering/submission/ssl/U_CN_D.key}{}}
U_C_CA_D = ${if exists{/usr/local/advancedfiltering/submission/ssl/U_CN_D-ca}{/usr/local/advancedfiltering/submission/ssl/U_CN_D-ca}{}}

# System Service Certificate
S_S_C_D = /usr/local/advancedfiltering/ssl/submission.services.advancedfiltering.net.crt
S_S_CK_D = /usr/local/advancedfiltering/ssl/submission.services.advancedfiltering.net.key
S_S_CA_D = /usr/local/advancedfiltering/ssl/ca

tls_advertise_hosts = *
tls_try_verify_hosts = *
tls_certificate = ${if bool{S_TH_F}{S_H_C_D}{${if bool_lax{U_C_C_D}{U_C_C_D}{S_S_C_D}}}}
tls_privatekey = ${if bool{S_TH_F}{S_H_CK_D}{${if bool_lax{U_C_CK_D}{U_C_CK_D}{S_S_CK_D}}}}
tls_verify_certificates = ${if bool{S_TH_F}{S_H_CA_D}{${if bool_lax{U_C_CA_D}{U_C_CA_D}{S_S_CA_D}}}}
tls_crl = ${if bool{S_TH_F}{S_H_CA_D}{${if bool_lax{U_C_CA_D}{U_C_CA_D}{S_S_CA_D}}}}

# TODO - user_hidereceived
received_header_text = Received:\
  ${if def:sender_rcvhost { from $sender_rcvhost}{ from localhost}} by $primary_hostname\
  ${if def:received_protocol { with $received_protocol}}\
  ${if def:tls_cipher { ($tls_cipher)}}\
  ${if def:tls_peerdn { ($tls_peerdn)}}\n \
  id $message_exim_id\
  ${if def:sender_address { (envelope-from <$sender_address>)}}\
  ${if def:received_for { for $received_for}}

message_size_limit = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMaxMessageSize?base}}

begin acl






# TODO







# User Realm
U_REALM_D = ${if eq{U_CN_D}{}{}{${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:U_CN_D},S_LDAP_DN?afSClientRealm?base}}}}


# System MailBox Timeout Data
S_MBTO_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMailBoxTimeout?base} }
# System Trusted Message Size
S_TMS_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionTrustedMessageSize?base} }

# TODO
mail_acl:
  accept

# User Submission Realm DN
U_Submission_R_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+U_Submission_LDAP_DN
# User Submission Realm Client DN
U_Submission_R_C_LDAP_DN = afUClientName=${quote_ldap_dn:$acl_m_u_client},U_Submission_R_LDAP_DN
# User Submission Realm Client Domain DN
U_Submission_R_C_D_LDAP_DN = afUSubmissionDomainName=${quote_ldap_dn:$acl_m_u_domain},U_Submission_R_C_LDAP_DN
# User Submission Realm Client Domain Mail Box DN
U_Submission_R_C_D_MB_LDAP_DN = afUSubmissionDMBLocalPart=${quote_ldap_dn:$local_part},U_Submission_R_C_D_LDAP_DN

# TODO
rcpt_acl:
  accept

# TODO
data_acl:
  accept

# TODO
begin routers

# Router Client
R_CLIENT = ${lookup ldap{LDAP_C/afSSubmissionDomainName=${quote_ldap_dn:$domain},S_Submission_LDAP_DN?afSSubmissionDomainClientName?base}}
# Router Client Realm
R_C_REALM = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:R_CLIENT},S_LDAP_DN?afSClientRealm?base}}

# (is needed for service_* routers and submission_* routers)
# Router Address_Data Realm LDAP Query (needed for service_* routers and submission_* routers)
R_AD_R_LDAP_Q = afSHostRealm=${quote_ldap_dn:${extract {realm} {$address_data} }}
# Router Address_Data Realm Flag
R_AD_R_F = ${extract {realm} {$address_data} }
# Router System Realm LDAP Query
R_SYS_R_LDAP_Q = ${reduce {S_REALMS} {|} {$value(afSHostRealm=${quote_ldap_dn:$item})} }
# Router Services Realm LDAP Q
R_S_R_LDAP_Q = ${if bool_lax{R_AD_R_F} {R_AD_R_LDAP_Q} {R_SYS_R_LDAP_Q} }

# * service

# errors_to addresses need to be verified
service_verify_router:
  verify_only = true
  domains = services.advancedfiltering.net
  driver = accept

service_router:
  domains = services.advancedfiltering.net
  driver = manualroute
  debug_print = address_data = $address_data, sys_r = R_SYS_R_LDAP_Q
  route_data = ${tr {${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_S_R_LDAP_Q)(afSHostServiceName=$local_part))} }} {\n} {:} }
  hosts_randomize = true
  transport = service_transport
  address_data = system_authenticator="true" $address_data
  errors_to = error@services.advancedfiltering.net

service_defer_router:
  domains = services.advancedfiltering.net
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net

begin transports

service_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/ssl/$primary_hostname.crt
  tls_privatekey = /etc/ssl/$primary_hostname.key
  tls_verify_certificates = /etc/ssl/ca
  tls_crl = /etc/ssl/ca
  # no return path fix

begin retry
^\N[^@]+@test\d+[^\.]*\.hosts\.advancedfiltering\.net$\N * F,5s,1s
services.advancedfiltering.net * F,15m,1m; H,7d,15m,2
* * F,2h,15m; G,16h,1h,1.5; F,4d,6h
