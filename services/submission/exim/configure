exim_user = exim
exim_group = exim
log_file_path = /usr/local/advancedfiltering/exim/%slog
process_log_path = /usr/local/advancedfiltering/exim/exim-process.info
spool_directory = /usr/local/advancedfiltering/exim
split_spool_directory = true
never_users = root
daemon_smtp_ports = 25 : 587
host_lookup = *
rfc1413_hosts = :
rfc1413_query_timeout = 0s
smtp_receive_timeout = 5s
local_scan_timeout = 15s
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d

# TODO
tls_advertise_hosts = *
tls_try_verify_hosts = *
tls_certificate = /usr/local/etc/ssl/smtp.services.advancedfiltering.net.crt
tls_privatekey = /usr/local/etc/ssl/smtp.services.advancedfiltering.net.key
tls_verify_certificates = /usr/local/etc/ssl/ca
tls_crl = /usr/local/etc/ssl/ca

acl_smtp_mail = mail_acl
acl_smtp_rcpt = rcpt_acl
acl_smtp_data = data_acl

# TODO
received_header_text = Received:\
  ${if def:sender_rcvhost { from $sender_rcvhost}{ from localhost}} by $primary_hostname\
  ${if def:received_protocol { with $received_protocol}}\
  ${if def:tls_cipher { ($tls_cipher)}}\
  ${if def:tls_peerdn { ($tls_peerdn)}}\n \
  id $message_exim_id\
  ${if def:sender_address { (envelope-from <$sender_address>)}}\
  ${if def:received_for { for $received_for}}

# Lightweight Directory Access Protocol Connection
LDAP_C = ldapi://%2fvar%2frun%2fopenldap%2fldapi
# System LDAP DN
S_LDAP_DN = ou=system,o=advancedfiltering
# System Submission LDAP DN
S_Submission_LDAP_DN = afSServiceName=submission,S_LDAP_DN
# User Submission LDAP DN
U_Submission_LDAP_DN = afUServiceName=submission,ou=user,o=advancedfiltering
# System Realms
S_REALMS = ${sg {${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$primary_hostname},S_LDAP_DN?afSHostRealm?base} }} {,\\s*} {:} }

message_size_limit = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMaxMessageSize?base} }

begin acl

# System MailBox Timeout Data
S_MBTO_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMailBoxTimeout?base} }
# System Trusted Message Size
S_TMS_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionTrustedMessageSize?base} }

# TODO
mail_acl:
  accept

# User Submission Realm DN
U_Submission_R_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+U_Submission_LDAP_DN
# User Submission Realm Client DN
U_Submission_R_C_LDAP_DN = afUClientName=${quote_ldap_dn:$acl_m_u_client},U_Submission_R_LDAP_DN
# User Submission Realm Client Domain DN
U_Submission_R_C_D_LDAP_DN = afUSubmissionDomainName=${quote_ldap_dn:$acl_m_u_domain},U_Submission_R_C_LDAP_DN
# User Submission Realm Client Domain Mail Box DN
U_Submission_R_C_D_MB_LDAP_DN = afUSubmissionDMBLocalPart=${quote_ldap_dn:$local_part},U_Submission_R_C_D_LDAP_DN

# TODO
rcpt_acl:
  accept

# TODO
data_acl:
  accept

# TODO
begin routers

# Router Client
R_CLIENT = ${lookup ldap{LDAP_C/afSSubmissionDomainName=${quote_ldap_dn:$domain},S_Submission_LDAP_DN?afSSubmissionDomainClientName?base}}
# Router Client Realm
R_C_REALM = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:R_CLIENT},S_LDAP_DN?afSClientRealm?base}}

# (is needed for service_* routers and submission_* routers)
# Router Address_Data Realm LDAP Query (needed for service_* routers and submission_* routers)
R_AD_R_LDAP_Q = afSHostRealm=${quote_ldap_dn:${extract {realm} {$address_data} }}
# Router Address_Data Realm Flag
R_AD_R_F = ${extract {realm} {$address_data} }
# Router System Realm LDAP Query
R_SYS_R_LDAP_Q = ${reduce {S_REALMS} {|} {$value(afSHostRealm=${quote_ldap_dn:$item})} }
# Router Services Realm LDAP Q
R_S_R_LDAP_Q = ${if bool_lax{R_AD_R_F} {R_AD_R_LDAP_Q} {R_SYS_R_LDAP_Q} }

# * service

# errors_to addresses need to be verified
service_verify_router:
  verify_only = true
  domains = services.advancedfiltering.net
  driver = accept

service_router:
  domains = services.advancedfiltering.net
  driver = manualroute
  debug_print = address_data = $address_data, sys_r = R_SYS_R_LDAP_Q
  route_data = ${tr {${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_S_R_LDAP_Q)(afSHostServiceName=$local_part))} }} {\n} {:} }
  hosts_randomize = true
  transport = service_transport
  address_data = system_authenticator="true" $address_data
  errors_to = error@services.advancedfiltering.net

service_defer_router:
  domains = services.advancedfiltering.net
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net

begin transports

service_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/ssl/$primary_hostname.crt
  tls_privatekey = /etc/ssl/$primary_hostname.key
  tls_verify_certificates = /etc/ssl/ca
  tls_crl = /etc/ssl/ca
  # no return path fix

begin retry
^\N[^@]+@test\d+[^\.]*\.hosts\.advancedfiltering\.net$\N * F,5s,1s
services.advancedfiltering.net * F,15m,1m; H,7d,15m,2
* * F,2h,15m; G,16h,1h,1.5; F,4d,6h
