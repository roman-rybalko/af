exim_user = advancedfiltering_submission
exim_group = advancedfiltering_submission
log_file_path = /usr/local/advancedfiltering/submission/exim/log/%s.log
process_log_path = /usr/local/advancedfiltering/submission/exim/exim-process.info
spool_directory = /usr/local/advancedfiltering/submission/exim/spool
split_spool_directory = true
never_users = root
daemon_smtp_ports = 587
# требуется для sys_trustedhost
host_lookup = *
rfc1413_hosts = :
rfc1413_query_timeout = 0s
smtp_receive_timeout = 42s
local_scan_timeout = 15s
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d
acl_smtp_mail = mail_acl
acl_smtp_rcpt = rcpt_acl
acl_smtp_data = data_acl
# * Режим submission (добавить From если нет, Sender, Date, Message-ID) без проверки From:, continue
local_from_check = false

# Lightweight Directory Access Protocol Connection
LDAP_C = ldapi://%2fusr%2flocal%2fadvancedfiltering%2fldap%2fldapi
# System LDAP DN
S_LDAP_DN = ou=system,o=advancedfiltering
# System Submission LDAP DN
S_Submission_LDAP_DN = afSServiceName=submission,S_LDAP_DN
# System Realm List (separated by coma)
S_REALM_Lc = ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$primary_hostname},S_LDAP_DN?afSHostRealm?base}}

# System Trusted Host Raw Flag
S_TH_R_F = ${if forany{<, ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$sender_host_name},S_LDAP_DN?afSHostRealm?base}}}{inlist{$item}{<, S_REALM_Lc}}{true}{false}}
# System Trusted Host Flag
S_TH_F = ${if eq{}{$sender_host_name}{false}{S_TH_R_F}}

# System Host Certificate
S_H_C_D = /etc/advancedfiltering_ssl/$primary_hostname.crt
# System Host Certificate Key
S_H_CK_D = /etc/advancedfiltering_ssl/$primary_hostname.key
# System Host Certificate Authority
S_H_CA_D = /etc/advancedfiltering_ssl/ca

# User Authenticated Client Name by IP
U_A_CN_ip_D = ${lookup ldap{LDAP_C/afSSubmissionAuthHostAddress=${quote_ldap_dn:$sender_host_address},S_Submission_LDAP_DN?afSSubmissionAuthClientName?base}}
# User Authenticated Client Name by TLS SNI (DNS name: submission.xxx.clients.advancedfiltering.net, submission2.xxx.clients.advancedfiltering.net)
U_A_CN_sni_D = ${sg{${sg{$tls_in_sni}{submission\\d*\\.}{}}}{\\.clients.advancedfiltering.net}{}}
# User Authenticated Client Name by SMTP AUTH
U_A_CN_login_D = $authenticated_id

# User Authenticated Client Name
U_A_CN_D = ${if eq{}{U_A_CN_ip_D}{${if eq{}{U_A_CN_sni_D}{${if eq{}{U_A_CN_login_D}{}{U_A_CN_login_D}}}{U_A_CN_sni_D}}}{U_A_CN_ip_D}}

# User Client Certificate
U_C_C_D = ${if exists{/usr/local/advancedfiltering/submission/ssl/U_A_CN_D.crt}{/usr/local/advancedfiltering/submission/ssl/U_A_CN_D.crt}{}}
U_C_CK_D = ${if exists{/usr/local/advancedfiltering/submission/ssl/U_A_CN_D.key}{/usr/local/advancedfiltering/submission/ssl/U_A_CN_D.key}{}}
U_C_CA_D = ${if exists{/usr/local/advancedfiltering/submission/ssl/U_A_CN_D-ca}{/usr/local/advancedfiltering/submission/ssl/U_A_CN_D-ca}{}}

# System Service Certificate
S_S_C_D = /usr/local/advancedfiltering/ssl/submission.services.advancedfiltering.net.crt
S_S_CK_D = /usr/local/advancedfiltering/ssl/submission.services.advancedfiltering.net.key
S_S_CA_D = /usr/local/advancedfiltering/ssl/ca

tls_advertise_hosts = *
tls_try_verify_hosts = *
tls_certificate = ${if bool{S_TH_F}{S_H_C_D}{${if bool_lax{U_C_C_D}{U_C_C_D}{S_S_C_D}}}}
tls_privatekey = ${if bool{S_TH_F}{S_H_CK_D}{${if bool_lax{U_C_CK_D}{U_C_CK_D}{S_S_CK_D}}}}
tls_verify_certificates = ${if bool{S_TH_F}{S_H_CA_D}{${if bool_lax{U_C_CA_D}{U_C_CA_D}{S_S_CA_D}}}}
tls_crl = ${if bool{S_TH_F}{S_H_CA_D}{${if bool_lax{U_C_CA_D}{U_C_CA_D}{S_S_CA_D}}}}

# * user_hidereceived => Удалить заголовки Received, continue
received_header_text = Received: \
  ${if bool{$acl_m_u_hr_f}{\
    from 192.168.0.42 by $primary_hostname \
  }{\
    from ${if def:sender_rcvhost { $sender_rcvhost}{ 192.168.0.2}} by $primary_hostname \
  }\
  ${if def:received_protocol {with $received_protocol }}\
  id $message_exim_id

# * message_size >= sys_maxmessagesize => 5xx ...
message_size_limit = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMaxMessageSize?base}}

begin acl

# * идентифицировать клиента
# deny => deny, accept => continue, defer => defer
auth_acl:

  # ** trusted_host && !certificate_verified => 5xx Trusted host certificate verification failed, stop
  deny
    condition = S_TH_F
    ! condition = $tls_in_certificate_verified
    message = Trusted host certificate verification failed

  # ** trusted_host => continue
  accept
    condition = S_TH_F

  # ** IP (client) && задан клиентский сертификат && !certificate_verified => 5xx Client (IP) certificate verification failed, stop
  deny
    condition = ${if bool_lax{U_A_CN_ip_D}}
    condition = ${if bool_lax{U_C_C_D}}
    ! condition = $tls_in_certificate_verified
    message = Client (IP) certificate verification failed

  # ** IP (client) => continue
  accept
    condition = ${if bool_lax{U_A_CN_ip_D}}

  # ** TLS SNI && задан клиентский сертификат && !certificate_verified => 5xx Client (TLS SNI) certificate verification failed, stop
  deny
    condition = ${if bool_lax{U_A_CN_sni_D}}
    condition = ${if bool_lax{U_C_C_D}}
    ! condition = $tls_in_certificate_verified
    message = Client (TLS SNI) certificate verification failed

  # ** TLS SNI => continue
  accept
    condition = ${if bool_lax{U_A_CN_sni_D}}
  
  # ** SMTP AUTH => continue
  accept
    condition = ${if bool_lax{U_A_CN_login_D}}

  # ** 5xx Authentication needed, stop
  deny
    message = Authentication needed

# Check user right to use sender address
# accept => continue, deny => deny
sender_auth_acl:

  # mbox
  accept
    condition = ${if eq{$acl_m_u_sender}{U_A_CN_login_D}}

  # mbox alias
  accept
    condition = ${if eq{${local_part:$acl_m_u_sender}@$acl_m_u_domain}{U_A_CN_login_D}}

  # domain
  accept
    condition = ${if eq{${domain:$acl_m_u_sender}}{U_A_CN_login_D}}

  # domain alias
  accept
    condition = ${if eq{$acl_m_u_domain}{U_A_CN_login_D}}

  # client SMTP AUTH
  accept
    condition = ${if eq{$acl_m_u_client}{U_A_CN_login_D}}

  # client TLS SNI
  accept
    condition = ${if eq{$acl_m_u_client}{U_A_CN_sni_D}}

  # client IP
  accept
    condition = ${if eq{$acl_m_u_client}{U_A_CN_ip_D}}

  # unknown
  deny

# System SMTP LDAP DN
S_SMTP_LDAP_DN = afSServiceName=smtp,S_LDAP_DN

# System MailBox Timeout Data
S_MBTO_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMailBoxTimeout?base}}
# System MailBox Cutoff Time Data
S_MBCT_D = ${eval10:$tod_epoch-S_MBTO_D}

# User Submission LDAP DN
U_Submission_LDAP_DN = afUServiceName=submission,ou=user,o=advancedfiltering

# User Submission Realm DN
U_Submission_R_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+U_Submission_LDAP_DN
# User Submission Realm Client DN
U_Submission_R_C_LDAP_DN = afUClientName=${quote_ldap_dn:$acl_m_u_client},U_Submission_R_LDAP_DN
# User Submission Realm Client Domain DN
U_Submission_R_C_D_LDAP_DN = afUSubmissionDomainName=${quote_ldap_dn:$acl_m_u_domain},U_Submission_R_C_LDAP_DN
# User Submission Realm Client Domain Mail Box DN
U_Submission_R_C_D_MB_LDAP_DN = afUSubmissionDMBLocalPart=${quote_ldap_dn:${local_part:$acl_m_u_sender}},U_Submission_R_C_D_LDAP_DN

# * проверка адреса отправителя
# deny => deny, accept => continue, defer => defer
sneder_acl:

  # ** домен не задан => 5xx Sender domain is absent, stop
  deny
    # User Domain
    set acl_m_u_domain = ${domain:$acl_m_u_sender}
    condition = ${if eq{}{$acl_m_u_domain}}
    message = $acl_m_u_sender_desc domain is absent

  # ** домен не зарегистрирован => 5xx Sender domain {domain:sender_address} is not in service, stop
  deny
    # User Client name/id
    set acl_m_u_client = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$acl_m_u_domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
    condition = ${if eq{}{$acl_m_u_client}}
    message = $acl_m_u_sender_desc domain $acl_m_u_domain is not in service

  # ** не наш realm домена => 4xx Moved, please try another host, stop
  defer
    # User Realm
    set acl_m_u_realm = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:$acl_m_u_client},S_LDAP_DN?afSClientRealm?base}}
    ! condition = ${if inlist{$acl_m_u_realm}{<, S_REALM_Lc}}
    message = Moved, please try another host

  # ** домен не принимает почту (verify = sender) => 5xx Sender domain {domain:sender_address} does not accept mail, stop
  deny
    ! verify = sender=$acl_m_u_sender
    message = $acl_m_u_sender_desc domain ${domain:$acl_m_u_sender} does not accept mail

  # ** раскрыть синоним, continue
  warn
    ! condition = ${if eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?afUSubmissionDomainAliasName?base}}}}
    set acl_m_u_domain = ${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?afUSubmissionDomainAliasName?base}}
  # блокируем двойной синоним
  defer
    ! condition = ${if eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?afUSubmissionDomainAliasName?base}}}}
    logwrite = :panic: Double domain alias: sender=$acl_m_u_sender client=$acl_m_u_client realm=$acl_m_u_realm domain=${domain:$acl_m_u_sender} alias=$acl_m_u_domain
    message = Configuration problem (double domain alias)

  # ** не зарегистрирован (или просрочен) и не проверяется адрес отправителя => 5xx Sender address {sender_address} does not exist, stop
  deny
    condition = ${if eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_MB_LDAP_DN?afUSubmissionDMBLocalPart?base?(afUSubmissionDMBTimeUpdated>=S_MBCT_D)}}}}
    ! condition = ${run{/usr/local/advancedfiltering/submission/mbxchk_vrfy/mbxchk_vrfy-exim.sh $acl_m_u_sender}{true}{false}}
    message = $acl_m_u_sender_desc address $acl_m_u_sender does not exist

  # ** !trusted_host && адрес отправителя не принадлежит аутентифицированному client/domain/rcpt => 5xx Authenticated user {user} may not use sender address {sender_address}, stop
  deny
    ! condition = S_TH_F
    ! acl = sender_auth_acl
    message = Authenticated user U_A_CN_D may not use sender address $acl_m_u_sender

  # ** нет DMARC (dmarc_verifier.pl "{domain:sender_address}") => 5xx DMARC is absent for sender domain {domain:sender_address}, stop
  deny
    ! condition = ${run{/usr/local/advancedfiltering/submission/exim/dmarc_verifier.pl ${domain:$acl_m_u_sender}}{true}{false}}
    message = DMARC is absent for sender domain ${domain:$acl_m_u_sender}

  # ** continue
  accept

# Load user configuration data
# accept - found, deny - not found
conf_acl:
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_Submission_R_C_D_MB_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{}{$acl_m_u_conf_value}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{}{$acl_m_u_conf_value}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_Submission_R_C_LDAP_DN?$acl_m_u_conf_name?base}}
    ! condition = ${if eq{}{$acl_m_u_conf_value}}
  deny

mail_acl:

  # * идентифицировать клиента
  deny
    ! acl = auth_acl

  # * присутствует адрес отправителя => проверка адреса отправителя (Sender), continue
  deny
    ! condition = ${if eq{}{$sender_address}}
    set acl_m_u_sender_desc = Sender
    set acl_m_u_sender = $sender_address
    ! acl = sender_acl

  # * отсутствует адрес отправителя => flag_spamsender, continue
  warn
    # SpamSender
    set acl_m_u_ss_f = false
    condition = ${if eq{}{$sender_address}}
    set acl_m_u_ss_f = true

  # * загрузить пользовательсике настройки (mbox/domain/client) => user_hidereceived, flag_spamsender, continue
  # afUSubmissionHideReceived
  warn
    # User Hide Received flag
    set acl_m_u_hr_f = false
    set acl_m_u_conf_name = afUSubmissionHideReceived
    acl = conf_acl
    set acl_m_u_hr_f = $acl_m_u_conf_value
  # afUSubmissionSpamSender
  warn
    ! condition = ${if bool{$acl_m_u_ss_f}}
    set acl_m_u_conf_name = afUSubmissionSpamSender
    acl = conf_acl
    set acl_m_u_ss_f = $acl_m_u_conf_value

  # * user_hidereceived => Удалить заголовки Received, continue
  warn
    condition = ${if bool{$acl_m_u_hr_f}}
    remove_header = Received

  # * Режим submission (добавить From если нет, Sender, Date, Message-ID) без проверки From:, continue
  warn
    control = submission

  # * 2xx, stop
  accept

rcpt_acl:

  # * домен не принимает почту (verify = recipient) => 5xx Recipient domain {domain} does not accept mail, stop
  deny
    ! verify = recipient
    message = Recipient domain $domain does not accept mail

  # * 2xx, stop
  accept

# System Trusted Message Size
S_TMS_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionTrustedMessageSize?base}}

# User Submission DataBase LDAP DN
U_SDB_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+afUServiceName=submissiondb,ou=user,o=advancedfiltering
# User Encoded Message ID
U_EMID_D = ${run{/usr/local/advancedfiltering/submission/exim/mid_list_encoder.pl $bheader_Message-ID:}{$value}{}}
# User Submission DataBase Sender
U_SDB_S_D = ${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:U_EMID_D},U_SDB_LDAP_DN?afUSMTPMessageSenderMailAddress?base}}
# User Headers Sender
U_H_S_D = ${if eq{}{$bheader_Reply-To:}{${address:$bheader_From:}}{${address:$bheader_Reply-To:}}}

data_acl:

  # * синтаксис заголовоков некорректен (verify = header_syntax) => 5xx Invalid message headers (Sender/From/Reply-To/To/Cc/Bcc), stop
  deny
    ! verify = header_syntax
    message = Invalid message headers (Sender/From/Reply-To/To/Cc/Bcc)

  # * заголовок From: содержит несколько адресов или битый => 5xx Invalid "From:" header, stop
  deny
    condition = ${if eq{}{${address:$bheader_From:}}}
    message = Invalid "From:" header

  # * заголовок "From:" содержит один адрес  => проверка адреса отправителя ("From:"), continue
  deny
    ! condition = ${if eq{}{${address:$bheader_From:}}}
    set acl_m_u_sender_desc = "From:"
    set acl_m_u_sender = ${address:$bheader_From:}
    ! acl = sender_acl

  # * DMARC не проверился (dmarc_verifier.pl "from domain" "spf domain" "dkim domain") => 5xx DMARC failed for "From:" domain {domain:header_from}, stop
  deny
    ! condition = ${run{/usr/local/advancedfiltering/submission/exim/dmarc_verifier.pl ${domain:${address:$bheader_From:}} ${domain:$sender_address} ${domain:${address:$bheader_From:}}}{true}{false}}
    message = DMARC failed for "From:" domain ${domain:${address:$bheader_From:}}

  # * присутствует заголовок "Reply-To:" && содержит несколько адресов или битый => 5xx Invalid "Reply-To:" header, stop
  deny
    ! condition = ${if eq{}{$bheader_Reply-To:}}
    condition = ${if eq{}{${address:$bheader_Reply-To:}}}
    message = Invalid "Reply-To:" header

  # * присутствует заголовок "Reply-To:" && домен в заголовке Reply-To: не принимает почту (verify = sender) => 5xx "Reply-To:" domain {domain:header_reply-to} does not accept mail, stop
  deny
    ! condition = ${if eq{}{$bheader_Reply-To:}}
    ! verify = sender=${address:$bheader_Reply-To:}
    message = "Reply-To:" domain ${domain:${address:$bheader_Reply-To:}} does not accept mail

  # * message-id в БД но sender другой => 5xx Duplicate, previous sender=prev-sender
  deny
    ! condition = ${if eq{}{U_SDB_S_D}}
    ! condition = ${if eq{U_H_S_D}{U_SDB_S_D}}
    message = Duplicate, previous sender=U_H_S_D

  # * msgsize >= sys_trustedmessagesize => flag_trustedmessagesize, log (trusted size), 2xx Trusted message size, stop
  accept
    set acl_m_u_tms_f = false
    condition = ${if >{$message_size}{S_TMS_D}}
    set acl_m_u_tms_f = true
    message = Trusted message size

  # * 2xx, stop
  accept

# TODO
begin routers

# Router Client
R_CLIENT = ${lookup ldap{LDAP_C/afSSubmissionDomainName=${quote_ldap_dn:$domain},S_Submission_LDAP_DN?afSSubmissionDomainClientName?base}}
# Router Client Realm
R_C_REALM = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:R_CLIENT},S_LDAP_DN?afSClientRealm?base}}

# (is needed for service_* routers and submission_* routers)
# Router Address_Data Realm LDAP Query (needed for service_* routers and submission_* routers)
R_AD_R_LDAP_Q = afSHostRealm=${quote_ldap_dn:${extract {realm} {$address_data} }}
# Router Address_Data Realm Flag
R_AD_R_F = ${extract {realm} {$address_data} }
# Router System Realm LDAP Query
R_SYS_R_LDAP_Q = ${reduce {S_REALMS} {|} {$value(afSHostRealm=${quote_ldap_dn:$item})} }
# Router Services Realm LDAP Q
R_S_R_LDAP_Q = ${if bool_lax{R_AD_R_F} {R_AD_R_LDAP_Q} {R_SYS_R_LDAP_Q} }

# * service

# errors_to addresses need to be verified
service_verify_router:
  verify_only = true
  domains = services.advancedfiltering.net
  driver = accept

service_router:
  domains = services.advancedfiltering.net
  driver = manualroute
  debug_print = address_data = $address_data, sys_r = R_SYS_R_LDAP_Q
  route_data = ${tr {${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_S_R_LDAP_Q)(afSHostServiceName=$local_part))} }} {\n} {:} }
  hosts_randomize = true
  transport = service_transport
  address_data = system_authenticator="true" $address_data
  errors_to = error@services.advancedfiltering.net

service_defer_router:
  domains = services.advancedfiltering.net
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net

begin transports

service_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = /etc/ssl/$primary_hostname.crt
  tls_privatekey = /etc/ssl/$primary_hostname.key
  tls_verify_certificates = /etc/ssl/ca
  tls_crl = /etc/ssl/ca
  # no return path fix

begin retry
^\N[^@]+@test\d+[^\.]*\.hosts\.advancedfiltering\.net$\N * F,5s,1s
services.advancedfiltering.net * F,15m,1m; H,7d,15m,2
* * F,2h,15m; G,16h,1h,1.5; F,4d,6h
