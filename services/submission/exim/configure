exim_user = af_submission
exim_group = af_submission
log_file_path = /usr/local/advancedfiltering/submission/exim/log/%s.log
process_log_path = /usr/local/advancedfiltering/submission/exim/spool/exim-process.info
spool_directory = /usr/local/advancedfiltering/submission/exim/spool
split_spool_directory = true
never_users = root
daemon_smtp_ports = 587
# требуется для sys_trustedhost
host_lookup = *
rfc1413_hosts = :
rfc1413_query_timeout = 0s
smtp_receive_timeout = 42s
local_scan_timeout = 15s
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d
acl_smtp_helo = helo_acl
acl_smtp_mail = mail_acl
acl_smtp_rcpt = rcpt_acl
acl_smtp_data = data_acl
# * Режим submission (добавить From если нет, Sender, Date, Message-ID) без проверки From:, continue
local_from_check = false
smtp_banner = submission.services.advancedfiltering.net ESMTP

# Lightweight Directory Access Protocol Connection
LDAP_C = ldapi://%2fusr%2flocal%2fadvancedfiltering%2fldap%2fldapi

# System LDAP DN
S_LDAP_DN = ou=system,o=advancedfiltering

# System SMTP LDAP DN
S_SMTP_LDAP_DN = afSServiceName=smtp,S_LDAP_DN
# System Submission LDAP DN
S_Submission_LDAP_DN = afSServiceName=submission,S_LDAP_DN

# User Submission LDAP DN
U_Submission_LDAP_DN = afUServiceName=submission,ou=user,o=advancedfiltering

# System Realm List (separated by coma)
S_REALM_Lc = ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$primary_hostname},S_LDAP_DN?afSHostRealm?base}}

# System Trusted Host Raw Flag
S_TH_R_F = ${if forany{<, ${lookup ldap{LDAP_C/afSHostName=${quote_ldap_dn:$sender_host_name},S_LDAP_DN?afSHostRealm?base}}}{inlist{$item}{<, S_REALM_Lc}}{true}{false}}
# System Trusted Host Flag
S_TH_F = ${if eq{}{$sender_host_name}{false}{S_TH_R_F}}

# User Authenticated Client Name by SMTP AUTH
U_CLIENT_login_D = $authenticated_id
# User Authenticated Client Name by TLS SNI (DNS name: submission.xxx.clients.advancedfiltering.net, submission2.xxx.clients.advancedfiltering.net)
U_CLIENT_sni_D = ${sg{${sg{$tls_in_sni}{submission\\d*\\.}{}}}{\\.clients.advancedfiltering.net}{}}
# User Authenticated Client Name by IP
U_CLIENT_ip_D = ${lookup ldap{LDAP_C/afSSubmissionAuthHostAddress=${quote_ldap_dn:$sender_host_address},S_Submission_LDAP_DN?afSSubmissionAuthClientName?base}}

# User login
U_CLIENT_D = ${if eq{}{U_CLIENT_login_D}{${if eq{}{U_CLIENT_sni_D}{${if eq{}{U_CLIENT_ip_D}{}{U_CLIENT_ip_D}}}{U_CLIENT_sni_D}}}{U_CLIENT_login_D}}

# User Realm
U_REALM_D = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:U_CLIENT_D},S_LDAP_DN?afSClientRealm?base}}

# User Client Certificate Raw Flag
U_C_C_R_F = ${lookup ldap{LDAP_C/afUClientName=${quote_ldap_dn:U_CLIENT_D},afUServiceRealm=${quote_ldap_dn:U_REALM_D}+U_Submission_LDAP_DN?afUSubmissionAuthHaveCertificate?base}}
# User Client Certificate
# проверяем, определился ли логин клиента, т.к. при SMTP AUTH логин до STARTTLS не известен
U_C_C_F = ${if eq{}{U_CLIENT_D}{}{U_C_C_R_F}}

# System Host Certificate
S_H_C_D = /etc/advancedfiltering_ssl/$primary_hostname.crt
# System Host Certificate Key
S_H_CK_D = /etc/advancedfiltering_ssl/$primary_hostname.key
# System Host Certificate Authority
S_H_CA_D = /etc/advancedfiltering_ssl/ca

# User Client Certificate
U_C_C_D = /usr/local/advancedfiltering/submission/ssl/U_CLIENT_D.crt
U_C_CK_D = /usr/local/advancedfiltering/submission/ssl/U_CLIENT_D.key
U_C_CA_D = /usr/local/advancedfiltering/submission/ssl/U_CLIENT_D.ca

# System Service Certificate
S_S_C_D = /usr/local/advancedfiltering/ssl/submission.services.advancedfiltering.net.crt
S_S_CK_D = /usr/local/advancedfiltering/ssl/submission.services.advancedfiltering.net.key
S_S_CA_D = /usr/local/advancedfiltering/ssl/ca

tls_advertise_hosts = *
tls_try_verify_hosts = *
# * установить сертификат
tls_certificate = ${if bool{S_TH_F}{S_H_C_D}{${if bool{U_C_C_F}{U_C_C_D}{S_S_C_D}}}}
tls_privatekey = ${if bool{S_TH_F}{S_H_CK_D}{${if bool{U_C_C_F}{U_C_CK_D}{S_S_CK_D}}}}
tls_verify_certificates = ${if bool{S_TH_F}{S_H_CA_D}{${if bool{U_C_C_F}{U_C_CA_D}{S_S_CA_D}}}}
tls_crl = ${if bool{S_TH_F}{S_H_CA_D}{${if bool{U_C_C_F}{U_C_CA_D}{S_S_CA_D}}}}

# * user_hidereceived => Удалить заголовки Received, continue
received_header_text = Received: \
  ${if bool{$acl_m_u_hr_f}{\
    from 192.168.0.42 by $primary_hostname \
  }{\
    from ${if def:sender_rcvhost { $sender_rcvhost}{ 192.168.0.2}} by $primary_hostname \
  }\
  ${if def:received_protocol {with $received_protocol }}\
  id $message_exim_id

# * message_size >= sys_maxmessagesize => 5xx ...
message_size_limit = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMaxMessageSize?base}}

# User Submission Realm DN
U_Submission_R_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+U_Submission_LDAP_DN
# User Submission Realm Client DN
U_Submission_R_C_LDAP_DN = afUClientName=${quote_ldap_dn:$acl_m_u_client},U_Submission_R_LDAP_DN
# User Submission Realm Client Domain DN
U_Submission_R_C_D_LDAP_DN = afUSubmissionDomainName=${quote_ldap_dn:$acl_m_u_domain},U_Submission_R_C_LDAP_DN
# User Submission Realm Client Domain Mail Box DN
U_Submission_R_C_D_MB_LDAP_DN = afUSubmissionDMBLocalPart=${quote_ldap_dn:${local_part:$acl_m_u_sender}},U_Submission_R_C_D_LDAP_DN

begin acl

helo_acl:

  # ** вывести логин клиента
  accept
    condition = ${if ! eq{}{U_CLIENT_login_D}}
    message = submission.services.advancedfiltering.net Hallo U_CLIENT_login_D SMTP AUTH
  accept
    condition = ${if ! eq{}{U_CLIENT_sni_D}}
    condition = ${if bool{U_C_C_F}}
    condition = $tls_in_certificate_verified
    message = submission.services.advancedfiltering.net Hallo U_CLIENT_sni_D TLS SNI
  accept
    condition = ${if ! eq{}{U_CLIENT_ip_D}}
    message = submission.services.advancedfiltering.net Hallo U_CLIENT_ip_D IP
  accept
    message = submission.services.advancedfiltering.net

# * идентифицировать клиента
# deny => deny, accept => continue, defer => defer
auth_acl:

  # ** trusted_host && !certificate_verified => 5xx Trusted host certificate verification failed, stop
  deny
    condition = S_TH_F
    ! condition = $tls_in_certificate_verified
    message = Trusted host certificate verification failed

  # ** trusted_host => continue
  accept
    condition = S_TH_F

  # ** логин определился && задан клиентский сертификат && !certificate_verified => 5xx Client certificate verification failed, stop
  deny
    condition = ${if ! eq{}{U_CLIENT_D}}
    condition = ${if bool{U_C_C_F}}
    ! condition = $tls_in_certificate_verified
    message = Client certificate verification failed

  # ** логин определился => continue
  accept
    condition = ${if ! eq{}{U_CLIENT_D}}

  # ** 5xx Authentication needed, stop
  deny
    message = Authentication needed

# Check user right to use sender address
# accept => continue, deny => deny
sender_auth_acl:

  # mbox
  accept
    condition = ${if eq{$acl_m_u_sender}{U_CLIENT_login_D}}

  # mbox alias
  accept
    condition = ${if eq{${local_part:$acl_m_u_sender}@$acl_m_u_domain}{U_CLIENT_login_D}}

  # domain
  accept
    condition = ${if eq{${domain:$acl_m_u_sender}}{U_CLIENT_login_D}}

  # domain alias
  accept
    condition = ${if eq{$acl_m_u_domain}{U_CLIENT_login_D}}

  # client SMTP AUTH
  accept
    condition = ${if eq{$acl_m_u_client}{U_CLIENT_login_D}}

  # client TLS SNI
  accept
    condition = ${if eq{$acl_m_u_client}{U_CLIENT_sni_D}}

  # client IP
  accept
    condition = ${if eq{$acl_m_u_client}{U_CLIENT_ip_D}}

  # unknown
  deny

mbxchk_acl:
  accept
    condition = ${run{/usr/local/advancedfiltering/submission/mbxchk/logexec/logexec-cli.sh AdvancedFiltering/MailBox/Check/AFsmtp<$acl_m_u_sender>}{true}{false}}
    logwrite = AdvancedFiltering/MailBox/submission/Add<$acl_m_u_sender>
  warn
    condition = ${if ! eq{1}{$runrc}}
    logwrite = :panic: AdvancedFiltering/MailBox/Check/AFsmtp<$acl_m_u_sender>: $value
  deny

# System MailBox Timeout Data
S_MBTO_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionMailBoxTimeout?base}}
# System MailBox Cutoff Time Data
S_MBCT_D = ${eval10:$tod_epoch-S_MBTO_D}

# * проверка адреса отправителя
# deny => deny, accept => continue, defer => defer
sneder_acl:

  # ** домен не задан => 5xx Sender domain is absent, stop
  deny
    # User Domain
    set acl_m_u_domain = ${domain:$acl_m_u_sender}
    condition = ${if eq{}{$acl_m_u_domain}}
    message = $acl_m_u_sender_desc domain is absent

  # ** домен не зарегистрирован => 5xx Sender domain {domain:sender_address} is not in service, stop
  deny
    # User Client name/id
    set acl_m_u_client = ${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$acl_m_u_domain},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}
    condition = ${if eq{}{$acl_m_u_client}}
    message = $acl_m_u_sender_desc domain $acl_m_u_domain is not in service

  # ** не наш realm домена => 4xx Moved, please try another host, stop
  defer
    # User Realm
    set acl_m_u_realm = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:$acl_m_u_client},S_LDAP_DN?afSClientRealm?base}}
    ! condition = ${if inlist{$acl_m_u_realm}{<, S_REALM_Lc}}
    message = Moved, please try another host

  # ** домен не принимает почту (verify = sender) => 5xx Sender domain {domain:sender_address} does not accept mail, stop
  deny
    ! verify = sender=$acl_m_u_sender
    message = $acl_m_u_sender_desc domain ${domain:$acl_m_u_sender} does not accept mail

  # ** синоним => user_domain, continue
  warn
    condition = ${if ! eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?afUSubmissionDomainAliasName?base}}}}
    set acl_m_u_domain = ${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?afUSubmissionDomainAliasName?base}}

  # ** двойной синоним => 4xx Configuration problem (double domain alias), panic, stop
  defer
    condition = ${if ! eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?afUSubmissionDomainAliasName?base}}}}
    logwrite = :panic: Double domain alias: sender=$acl_m_u_sender client=$acl_m_u_client realm=$acl_m_u_realm domain=${domain:$acl_m_u_sender} alias=$acl_m_u_domain
    message = Configuration problem (double domain alias)

  # ** не найден в ou=user => 4xx Replicating, please try again later, stop
  defer
    condition = ${if eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?objectClass?base}}}}
    message = Replicating, please try again later

  # ** не зарегистрирован и не проверяется адрес отправителя => 5xx Sender address {sender_address} does not exist, stop
  deny
    condition = ${if eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_MB_LDAP_DN?afUSubmissionDMBLocalPart?base}}}}
    ! acl = mbxchk_acl
    message = $acl_m_u_sender_desc address $acl_m_u_sender does not exist

  # ** просрочен адрес отправителя => записать в лог задание на проверку, continue
  warn
    condition = ${if eq{}{${lookup ldap{LDAP_C/U_Submission_R_C_D_MB_LDAP_DN?afUSubmissionDMBLocalPart?base?(afUSubmissionDMBTimeUpdated>=S_MBCT_D)}}}}
    logwrite = AdvancedFiltering/MailBox/Check/AFsmtp<$acl_m_u_sender> ? AdvancedFiltering/MailBox/submission/Update<$acl_m_u_sender> : AdvancedFiltering/MailBox/submission/Delete<$acl_m_u_sender>

  # ** !trusted_host && адрес отправителя не принадлежит аутентифицированному client/domain/rcpt => 5xx Authenticated user {user} may not use sender address {sender_address}, stop
  deny
    ! condition = S_TH_F
    ! acl = sender_auth_acl
    message = Authenticated user U_CLIENT_D may not use sender address $acl_m_u_sender

  # ** нет DMARC (dmarc_verifier.pl "{domain:sender_address}") => 5xx DMARC is absent for sender domain {domain:sender_address}, stop
  deny
    ! condition = ${run{/usr/local/advancedfiltering/submission/exim/dmarc_verifier.pl ${domain:$acl_m_u_sender}}{true}{false}}
    message = DMARC is absent for sender domain ${domain:$acl_m_u_sender} (${if eq{1}{$runrc}{$value}{internal error}})
    logwrite = ${if eq{1}{$runrc}{}{:panic: }}DMARC: $value

  # ** continue
  accept

# Load user configuration data
# accept - found, deny - not found
conf_acl:
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_Submission_R_C_D_MB_LDAP_DN?$acl_m_u_conf_name?base}}
    condition = ${if ! eq{}{$acl_m_u_conf_value}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?$acl_m_u_conf_name?base}}
    condition = ${if ! eq{}{$acl_m_u_conf_value}}
  accept
    set acl_m_u_conf_value = ${lookup ldap{LDAP_C/U_Submission_R_C_LDAP_DN?$acl_m_u_conf_name?base}}
    condition = ${if ! eq{}{$acl_m_u_conf_value}}
  deny

mail_acl:

  # * идентифицировать клиента
  deny
    ! acl = auth_acl

  # * присутствует адрес отправителя => проверка адреса отправителя (Sender), continue
  deny
    condition = ${if ! eq{}{$sender_address}}
    set acl_m_u_sender_desc = Sender
    set acl_m_u_sender = $sender_address
    ! acl = sender_acl

  # * отсутствует адрес отправителя => flag_spamsender, continue
  warn
    # User SpamSender flag
    set acl_m_u_ss_f = false
    condition = ${if eq{}{$sender_address}}
    set acl_m_u_ss_f = true

  # * загрузить пользовательсике настройки (mbox/domain/client) => user_hidereceived, flag_spamsender, continue
  # afUSubmissionHideReceived
  warn
    # User Hide Received flag
    set acl_m_u_hr_f = false
    set acl_m_u_conf_name = afUSubmissionHideReceived
    acl = conf_acl
    set acl_m_u_hr_f = $acl_m_u_conf_value
  # afUSubmissionSpamSender
  warn
    ! condition = ${if bool{$acl_m_u_ss_f}}
    set acl_m_u_conf_name = afUSubmissionSpamSender
    acl = conf_acl
    set acl_m_u_ss_f = $acl_m_u_conf_value

  # * user_hidereceived => Удалить заголовки Received, continue
  warn
    condition = ${if bool{$acl_m_u_hr_f}}
    remove_header = Received

  # * Режим submission (добавить From если нет, Sender, Date, Message-ID) без проверки From:, continue
  warn
    control = submission

  # * 2xx, stop
  accept

rcpt_acl:

  # * домен не принимает почту (verify = recipient) => 5xx Recipient domain {domain} does not accept mail, stop
  deny
    ! verify = recipient
    message = Recipient domain $domain does not accept mail

  # * 2xx, stop
  accept

# System Trusted Message Size
S_TMS_D = ${lookup ldap{LDAP_C/S_Submission_LDAP_DN?afSSubmissionTrustedMessageSize?base}}

# User Submission DataBase LDAP DN
U_SDB_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+afUServiceName=submissiondb,ou=user,o=advancedfiltering
# User Submission DB Encoded Message ID
U_SDB_EMID_D = ${run{/usr/local/advancedfiltering/submission/exim/mid_list_encoder.pl $bheader_Message-ID:}{$value}{}}
# User Submission DataBase Sender
U_SDB_S_D = ${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:U_SDB_EMID_D},U_SDB_LDAP_DN?afUSMTPMessageSenderMailAddress?base}}
# User Headers Sender
U_H_S_D = ${if eq{}{$bheader_Reply-To:}{${address:$bheader_From:}}{${address:$bheader_Reply-To:}}}

# User SMTP DataBase LDAP DN
U_SMTPDB_LDAP_DN = afUServiceRealm=${quote_ldap_dn:$acl_m_u_realm}+afUServiceName=smtpdb,ou=user,o=advancedfiltering
# User SMTP DB Encoded Message ID
U_SMTPDB_EMID_L = ${run{/usr/local/advancedfiltering/submission/exim/mid_list_encoder.pl $bheader_In-Reply-To: $bheader_References:}{$value}{}}
# User SMTP DB Sender list
U_SMTPDB_S_L = ${map{U_SMTPDB_EMID_L}{${lookup ldap{LDAP_C/afUSMTPMessageId=${quote_ldap_dn:$item},U_SMTPDB_LDAP_DN?afUSMTPMessageSenderMailAddress?base}}}}

data_acl:
  # $recipients не доступен в routers
  warn
    set acl_m_u_recipients = $recipients

  # * синтаксис заголовоков некорректен (verify = header_syntax) => 5xx Invalid message headers (Sender/From/Reply-To/To/Cc/Bcc), stop
  deny
    ! verify = header_syntax
    message = Invalid message headers (Sender/From/Reply-To/To/Cc/Bcc)

  # * есть заголовок X-AdvancedFiltering-MessageData-Submission => 5xx Message loop detected, stop
  deny
    condition = ${if ! eq{}{$rheader_X-AdvancedFiltering-MessageData-Submission:}}
    message = Message loop detected: $rheader_X-AdvancedFiltering-MessageData-Submission:

  # * заголовок From: содержит несколько адресов или битый => 5xx Invalid "From:" header, stop
  deny
    condition = ${if eq{}{${address:$bheader_From:}}}
    message = Invalid "From:" header

  # * заголовок "From:" содержит один адрес  => проверка адреса отправителя ("From:"), continue
  deny
    condition = ${if ! eq{}{${address:$bheader_From:}}}
    set acl_m_u_sender_desc = "From:"
    set acl_m_u_sender = ${address:$bheader_From:}
    ! acl = sender_acl

  # * DMARC не проверился (dmarc_verifier.pl "from domain" "spf domain" "dkim domain") => 5xx DMARC failed for "From:" domain {domain:header_from}, stop
  deny
    ! condition = ${run{/usr/local/advancedfiltering/submission/exim/dmarc_verifier.pl ${domain:${address:$bheader_From:}} ${domain:$sender_address} ${domain:${address:$bheader_From:}}}{true}{false}}
    message = DMARC failed for "From:" domain ${domain:${address:$bheader_From:}} (${if eq{1}{$runrc}{$value}{internal error}})
    logwrite = ${if eq{1}{$runrc}{}{:panic: }}DMARC: $value

  # * присутствует заголовок "Reply-To:" && содержит несколько адресов или битый => 5xx Invalid "Reply-To:" header, stop
  deny
    condition = ${if ! eq{}{$bheader_Reply-To:}}
    condition = ${if eq{}{${address:$bheader_Reply-To:}}}
    message = Invalid "Reply-To:" header

  # * присутствует заголовок "Reply-To:" && домен в заголовке Reply-To: не принимает почту (verify = sender) => 5xx "Reply-To:" domain {domain:header_reply-to} does not accept mail, stop
  deny
    condition = ${if ! eq{}{$bheader_Reply-To:}}
    ! verify = sender=${address:$bheader_Reply-To:}
    message = "Reply-To:" domain ${domain:${address:$bheader_Reply-To:}} does not accept mail

  # * message-id в БД но sender другой => 5xx Duplicate, previous sender=prev-sender
  deny
    condition = ${if ! eq{}{U_SDB_S_D}}
    ! condition = ${if eq{U_H_S_D}{U_SDB_S_D}}
    message = Duplicate, previous sender=U_H_S_D

  # * in-reply-to, references в БД и sender в recipients => flag_hamtrap, continue
  warn
    # User HamTrap flag
    set acl_m_u_ht_f = false
    condition = ${if forany{U_SMTPDB_S_L}{inlist{$item}{<, $recipients}}}
    set acl_m_u_ht_f = true
    logwrite = AdvancedFiltering/MessageID/submissiondb/Add<$acl_m_u_realm><U_SDB_EMID_D><U_H_S_D>

  # * msgsize >= sys_trustedmessagesize => flag_trustedmessagesize, log (trusted size), 2xx Trusted message size, stop
  accept
    set acl_m_u_tms_f = false
    condition = ${if >{$message_size}{S_TMS_D}}
    set acl_m_u_tms_f = true
    message = Trusted message size
    logwrite = AdvancedFiltering/MessageID/submissiondb/Add<$acl_m_u_realm><U_SDB_EMID_D><U_H_S_D>

  # * 2xx, stop
  accept

begin routers

# * service

# errors_to addresses need to be verified
service_verify_router:
  verify_only = true
  domains = services.advancedfiltering.net
  driver = accept

# Router User Realm LDAP Query
R_U_R_LDAP_Q = afSHostRealm=${quote_ldap_dn:${extract {realm} {$address_data} }}
# Router Host Realm LDAP Query
R_H_R_LDAP_Q = ${reduce{<, S_REALM_Lc}{|}{$value(afSHostRealm=${quote_ldap_dn:$item})}}
# Router Services Realm LDAP Query
R_S_R_LDAP_Q = ${if eq{}{$acl_m_u_realm}{R_H_R_LDAP_Q}{R_U_R_LDAP_Q}}

# Routers/Service Router Route Data Hosts List (separated by \n)
R_SRRD_H_Lnl = ${lookup ldapm{LDAP_C/S_LDAP_DN?afSHostName?sub?(&(R_S_R_LDAP_Q)(afSHostServiceName=$local_part))}}
# Routers/Service Router Route Data Address (uses $item)
R_SRRD_address_I = ${lookup ldap{LDAP_C/afSHostServiceName=$local_part,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceHostAddress?base}}
# Routers/Service Router Route Data Port (uses $item)
R_SRRD_port_I = ${lookup ldap{LDAP_C/afSHostServiceName=$local_part,afSHostName=${quote_ldap_dn:$item},S_LDAP_DN?afSHServiceTCPPort?base}}
# Routers/Service Router Route Data List (separated by \n)
R_SRRD_Lnl = ${map{<\n R_SRRD_H_Lnl}{${if bool_lax{R_SRRD_address_I}{R_SRRD_address_I}{$item}}${if bool_lax{R_SRRD_port_I}{:R_SRRD_port_I}{}}}}

# * service [@services] {stop} => error
service_router:
  domains = services.advancedfiltering.net
  driver = manualroute
  route_data = \"<\n R_SRRD_Lnl\"
  hosts_randomize = true
  transport = service_transport
  # error delivery loop prevention
  errors_to = ${if eqi{$local_part}{error}{}{error@services.advancedfiltering.net}}
  self = send

# * service_defer [@services] {stop} -> service => error
service_defer_router:
  domains = services.advancedfiltering.net
  driver = redirect
  allow_defer = true
  data = :defer:
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router

# * internet_verify {stop} => bounce
internet_verify_router:
  verify_only = true
  driver = dnslookup
  errors_to = bounce@services.advancedfiltering.net
  self = send
  more = false

# * hamtrap [flag_hamtrap] {continue} -> service => error
hamtrap_router:
  condition = $acl_m_u_ht_f
  driver = redirect
  data = hamtrap@services.advancedfiltering.net
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router
  unseen = true

# * mailproc [!flag_trustedmessagesize && !flag_hamtrap] {continue} -> service => error
mailproc_router:
  condition = ${if ! bool{$acl_m_u_tms_f}}
  condition = ${if ! bool{$acl_m_u_ht_f}}
  driver = redirect
  data = mailproc@services.advancedfiltering.net
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router
  unseen = true

# Router general LDAP DN
R_LDAP_DN = ""

# Router Copy Target List (separated by coma)
R_CT_Lc = ""

# Router Copy Sender Data
R_CS_D = ""

# * backup_rcpt {continue} -> internet >> backup_end => error
R_LDAP_DN == U_Submission_R_C_D_MB_LDAP_DN
R_CS_D == $local_part@$domain
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSubmissionBackupMailAddress?base}}
backup_rcpt_router:
  # prevent address_data update
  condition = ${if ! eq{}{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = internet_router
  unseen = true
backup_rcpt_pass_router:
  condition = ${if ! eq{}{R_CT_Lc}}
  driver = redirect
  data = $local_part@$domain
  errors_to = error@services.advancedfiltering.net
  redirect_router = backup_end_router

# * backup_client {continue} -> internet >> backup_end => error
R_LDAP_DN == U_Submission_R_C_D_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSubmissionDomainTechMailAddress?base}}
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSubmissionBackupMailAddress?base}}
backup_domain_router:
  # prevent address_data update
  condition = ${if ! eq{}{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = internet_router
  unseen = true
backup_domain_pass_router:
  condition = ${if ! eq{}{R_CT_Lc}}
  driver = redirect
  data = $local_part@$domain
  errors_to = error@services.advancedfiltering.net
  redirect_router = backup_end_router

# * backup_client {continue} -> internet >> backup_end => error
R_LDAP_DN == U_Submission_R_C_LDAP_DN
R_CS_D == ${lookup ldap{LDAP_C/R_LDAP_DN?afUClientTechMailAddress?base}}
# the same for all backup_ routers
R_CT_Lc == ${lookup ldap{LDAP_C/R_LDAP_DN?afUSubmissionBackupMailAddress?base}}
backup_client_router:
  # prevent address_data update
  condition = ${if ! eq{}{R_CT_Lc}}
  driver = redirect
  data = R_CT_Lc
  address_data = sender=R_CS_D $address_data
  errors_to = error@services.advancedfiltering.net
  redirect_router = internet_router
  unseen = true
backup_client_pass_router:
  condition = ${if ! eq{}{R_CT_Lc}}
  driver = redirect
  data = $local_part@$domain
  errors_to = error@services.advancedfiltering.net
  redirect_router = backup_end_router

# * backup_end
backup_end_router:
  driver = redirect
  data = ""

# Router MessageData Submission Info
R_MDS_I_D = $acl_m_u_client $sender_address $message_exim_id
# Router MessageData Submission Key
R_MDS_K_D = l8JI6T7kctCno3lL44hqNOQ0NnWvjpVZn4WCFvuBxp
# Router MessageData Submission Header
R_MDS_H_D = ${str2b64:R_MDS_I_D ${md5:R_MDS_I_D R_MDS_K_D}}

# * spamsender [flag_spamsender] {stop} -> service => error
spamsender_router:
  condition = $acl_m_u_ss_f
  driver = redirect
  data = spamsender@services.advancedfiltering.net
  errors_to = error@services.advancedfiltering.net
  redirect_router = service_router
  headers_remove = X-Envelope-From:X-Envelope-To
  headers_add = X-Envelope-From: $sender_address\nX-Envelope-To: $acl_m_u_recipients
  headers_add = X-AdvancedFiltering-MessageData-Submission: R_MDS_H_D

# * internet {stop} => bounce
internet_router:
  driver = dnslookup
  transport = internet_transport
  errors_to = bounce@services.advancedfiltering.net
  self = send
  headers_add = X-AdvancedFiltering-MessageData-Submission: R_MDS_H_D

begin transports

service_transport:
  driver = smtp
  # mandatory tls
  hosts_require_tls = *
  # system cert, verify
  tls_certificate = S_H_C_D
  tls_privatekey = S_H_CK_D
  tls_verify_certificates = S_H_CA_D
  tls_crl = S_H_CA_D

internet_transport:
  driver = smtp
  # public cert, no verify
  tls_certificate = S_S_C_D
  tls_privatekey = S_S_CK_D
  tls_verify_certificates = S_S_CA_D
  dkim_domain = ${domain:${address:$bheader_From:}}
  dkim_selector = ${lookup ldap{LDAP_C/U_Submission_R_C_D_LDAP_DN?afUSubmissionDomainDKIMSelector?base}}
  dkim_private_key = /usr/local/advancedfiltering/submission/dkim/$acl_m_u_client.key
  dkim_canon = relaxed
  dkim_strict = true

begin retry

# DEBUG
^\N[^@]+@test\-smtp\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@w01\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@w02\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@h01\.hosts\.advancedfiltering\.net$\N * F,5s,1s
^\N[^@]+@h02\.hosts\.advancedfiltering\.net$\N * F,5s,1s

services.advancedfiltering.net * F,15m,1m; H,7d,15m,2
bounce@services.advancedfiltering.net * F,15m,1m; F,1d,15m

* rcpt_4xx F,1m,5s; F,15m,1m; F,1h,15m; F,1d,1h
* * F,15m,1m; F,1h,15m; F,1d,1h

begin authenticators

# Authenticator MailBox Realm
A_MB_R_D = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:${domain:$auth2}},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}},S_LDAP_DN?afSClientRealm?base}}
# Authenticator Domain Realm
A_D_R_D = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$auth2},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}},S_LDAP_DN?afSClientRealm?base}}
# Authenticator Client Realm
A_C_R_D = ${lookup ldap{LDAP_C/afSClientName=${quote_ldap_dn:$auth2},S_LDAP_DN?afSClientRealm?base}}

# Authenticator Realm
A_REALM_D = ${if eq{}{A_MB_R_D}{${if eq{}{A_D_R_D}{${if eq{}{A_C_R_D}{}{A_C_R_D}}}{A_D_R_D}}}{A_MB_R_D}}

# Authenticator MailBox Password Raw
A_MB_P_R_D = ${lookup ldap{LDAP_C/afUSubmissionDMBLocalPart=${quote_ldap_dn:${local_part:$auth2}},afUSubmissionDomainName=${quote_ldap_dn:${domain:$auth2}},afUClientName=${quote_ldap_dn:${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:{$domain:$auth2}},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}},afUServiceRealm=${quote_ldap_dn:A_REALM_D}+U_Submission_LDAP_DN?afUSubmissionAuthPassword?base}}
# Authenticator MailBox Password (additional check for invalid LDAP query prevention)
A_MB_P_D = ${if and{{!eq{}{${local_part:$auth2}}}{!eq{}{${domain:$auth2}}}}{A_MB_P_R_D}{}}
# Authenticator Domain Password
A_D_P_D = ${lookup ldap{LDAP_C/afUSubmissionDomainName=${quote_ldap_dn:$auth2},afUClientName=${quote_ldap_dn:${lookup ldap{LDAP_C/afSSMTPDomainName=${quote_ldap_dn:$auth2},S_SMTP_LDAP_DN?afSSMTPDomainClientName?base}}},afUServiceRealm=${quote_ldap_dn:A_REALM_D}+U_Submission_LDAP_DN?afUSubmissionAuthPassword?base}}
# Authenticator Client Password
A_C_P_D = ${lookup ldap{LDAP_C/afUClientName=${quote_ldap_dn:$auth2},afUServiceRealm=${quote_ldap_dn:A_REALM_D}+U_Submission_LDAP_DN?afUSubmissionAuthPassword?base}}

# Authenticator server_advertise_condition
A_SAC_D = ${if ! eq{}{$tls_in_cipher}}
# Authenticator server_condition Password
A_SC_P_F = ${if crypteq{$auth3}{A_MB_P_D}{true}{${if crypteq{$auth3}{A_D_P_D}{true}{${if crypteq{$auth3}{A_C_P_D}{true}{false}}}}}}
# Authenticator server_condition
A_SC_D = ${if inlist{A_REALM_D}{<, S_REALM_Lc}{A_SC_P_F}{Moved, please try another host}}

login_authenticator:
  server_advertise_condition = A_SAC_D
  server_condition = A_SC_D
  driver = plaintext
  public_name = LOGIN
  server_prompts = User Name : Password
  server_set_id = $auth2

plain_authenticator:
  server_advertise_condition = A_SAC_D
  server_condition = A_SC_D
  driver = plaintext
  public_name = PLAIN
  server_prompts = :
  server_set_id = $auth2
